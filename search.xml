<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程同步</title>
      <link href="/2023/09/21/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/09/21/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的线程同步"><a href="#C语言中的线程同步" class="headerlink" title="C语言中的线程同步"></a>C语言中的线程同步</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>当一个线程对内存中的共享资源进行访问的时候，其他线程都不可以操作这块内存，直到线程 A 对这块内存访问完毕为止。</p><h2 id="2-为什么要实现线程同步"><a href="#2-为什么要实现线程同步" class="headerlink" title="2 为什么要实现线程同步"></a>2 为什么要实现线程同步</h2><p>为了使多个线程操作同一个全局变量的时候，全局变量的数据被及时正确的读取、计算、写入内存中，保证程序正确的执行下去。</p><h2 id="3-同步方式"><a href="#3-同步方式" class="headerlink" title="3 同步方式"></a>3 同步方式</h2><ul><li>互斥锁 </li><li>读写锁</li><li>条件变量</li><li>信号量</li></ul><blockquote><p>所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为临界资源。</p></blockquote><p><img src="/../%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/image-20200106092600543.png" alt="image-20200106092600543"></p><ul><li>临界区上边上锁，下边解锁</li></ul><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1. 互斥锁"></a>1. 互斥锁</h3><ul><li><p>通过互斥锁可以锁定一个代码块，</p></li><li><p>被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要<strong>付出的代价就是执行效率的降低</strong>，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p></li><li><p>创建一把互斥锁</p><pre><code class="c">pthread_mutex_t mutex;</code></pre><pre><code class="c">// 初始化互斥锁// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);// 释放互斥锁资源            int pthread_mutex_destroy(pthread_mutex_t *mutex);//参数://mutex: 互斥锁变量的地址//attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</code></pre></li><li><p>上锁</p><pre><code class="c">int pthread_mutex_lock(pthread_mutex_t* mutex);</code></pre></li><li><p>尝试加锁</p><pre><code class="c">int pthread_mutex_trylock(pthread_mutex* mutex);//如果锁变量是锁定的，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号。</code></pre></li><li><p>解锁</p><pre><code class="c">int pthread_mutex_unlock(pthread_mutex* mutex);//不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</code></pre></li></ul><blockquote><p><strong>死锁</strong>：锁使用不当，如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有：</p><ul><li><p>加锁后忘记解锁</p></li><li><p>重复加锁，造成死锁</p></li><li><p>程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p><pre><code class="text">场景描述:  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B     - 线程A访问资源X, 加锁A     - 线程B访问资源Y, 加锁B  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞     - 线程A被锁B阻塞了, 无法打开A锁     - 线程B被锁A阻塞了, 无法打开B锁</code></pre></li></ul></blockquote><h3 id="2-读写锁-–-是互斥锁的升级版"><a href="#2-读写锁-–-是互斥锁的升级版" class="headerlink" title="2. 读写锁  – (是互斥锁的升级版)"></a>2. 读写锁  – (是互斥锁的升级版)</h3><ul><li><p>创建 ：<code>pthread_rwlock_t rwlock;</code> </p></li><li><p>在<strong>做读操作的时候可以提高程序的执行效率</strong>，如果所有的线程都是做读操作, 那么读是并行的</p></li><li><p>如果读写锁锁定了读操作，需要先解锁才能锁定写操作，反之亦然。</p></li><li><p>读写锁的特点：</p><ol><li>读锁是共享的</li><li>写锁是独占的</li><li>写锁比读锁的优先级高。</li></ol></li></ul><blockquote><p>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源<strong>读的操作越多，读写锁更有优势</strong>。</p></blockquote><ul><li><ul><li>读写锁是一把锁， 锁定了读操作，就不能锁定写操作了，不能同时锁定。</li></ul></li><li>读写锁的操作函数</li></ul><pre><code class="c">#include&lt;pthread.h&gt;pthread_rwlock_t rwlock;//初始化读写锁int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t* restrict attr);//attr: 读写锁属性，一般使用默认属性，指定为 NULL//释放读写锁占用的系统资源int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);//加读锁int phtread_rwlock_rdlock(pthread_rwlock_t* rwlocck);int phtread_rwlock_tryrdlock(pthread_rwlock_t* rwlocck);//加写锁int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);// 解锁, 不管锁定了读还是写都可用解锁int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></pre><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h3><p><strong>条件变量的主要作用不是处理线程同步，而是进行线程的阻塞</strong>。<strong>在多线程程序中，条件变量需要配合互斥锁来使用。</strong></p><p>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</p><p><strong>分工</strong>：互斥锁用来做线程同步；条件变量用来阻塞线程的。</p><ul><li>条件变量的操作函数如下：</li></ul><pre><code class="c">#include&lt;pthread.h&gt;pthread_cond_t cond;//初始化int pthread_cond_init(pthread_cond_t* restrict cond, const pthread_condattr_t* restrict attr);//att 指定为NULL// 销毁释放资源        int pthread_cond_destroy(pthread_cond_t *cond);// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示struct timespec &#123;    time_t tv_sec;      /* Seconds */    long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */&#125;;// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了int pthread_cond_timedwait(pthread_cond_t *restrict cond,           pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞int pthread_cond_signal(pthread_cond_t *cond);// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞int pthread_cond_broadcast(pthread_cond_t *cond);</code></pre><h4 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h4><p><img src="/../%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/1564644834918.png" alt="1564644834918"></p><p>生产者和消费者模型的组成：</p><ol><li>生产者线程 -&gt; 若干个<ol><li>生产商品或者任务放入到任务队列中</li><li>任务队列满了就阻塞，不满的时候就工作</li><li>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</li></ol></li><li>消费者线程 -&gt; 若干个<ol><li>读任务队列，将任务或者数据取出</li><li>任务队列中有数据就消费，没有数据就阻塞</li><li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li></ol></li><li>队列-&gt;存储任务 &#x2F; 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存<ul><li>可以是数组、链表，也可以使用 <code>stl</code>容器：<code>queue / stack / list / vector</code></li></ul></li></ol><h3 id="4-信号量–-用起来比条件变量简单"><a href="#4-信号量–-用起来比条件变量简单" class="headerlink" title="4. 信号量–  用起来比条件变量简单"></a>4. 信号量–  用起来比条件变量简单</h3><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。<strong>信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</strong></p><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为 <code>&lt;semaphore.h&gt;：</code></p><p>信号量操作函数如下：</p><pre><code class="c">#include&lt;semaphore.h&gt;//创建信号量sem_t sem1;sem_t sem2;//初始化信号量/灯int sem_init(sem_t* sem, int pshared, unsigned int value);// 资源释放, 线程销毁之后调用这个函数即可// 参数 sem 就是 sem_init() 的第一个参数       int sem_destroy(sem_t* sem);</code></pre><blockquote><p>参数:<br><code>sem</code>：信号量变量地址<br><code>pshared</code>：<br>0：线程同步<br>非 0：进程同步<br>value：初始化当前信号量拥有的资源数（&gt;&#x3D;0），如果资源数为 0，线程就会被阻塞了.</p></blockquote><pre><code class="c">// 参数 sem 就是 sem_init() 的第一个参数  // 函数被调用sem中的资源就会被消耗1个, 资源数-1int sem_wait(sem_t *sem);int sem_trywait(sem_t *sem); // sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号</code></pre><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p><pre><code class="c">//调用调用该函数给sem中的资源数+1int sem_post(sem_t* sem);//查看信号量sem中的整型数的当前值，个值会被写入到sval指针对应的内存中// sval是一个传出参数int sem_getvalue(sem_t* sem, int* sval);</code></pre><h4 id="总资源数为1"><a href="#总资源数为1" class="headerlink" title="总资源数为1"></a>总资源数为1</h4><p>如果生产者和消费者使用的信号量总资源数为 1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p><h4 id="总资源数大于-1"><a href="#总资源数大于-1" class="headerlink" title="总资源数大于 1"></a><strong>总资源数大于 1</strong></h4><p><strong>为防止共享资源出现数据混乱，需要使用互斥锁进行线程同步。</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;semaphore.h&gt;#include &lt;pthread.h&gt;// 链表的节点struct Node&#123;    int number;    struct Node* next;&#125;;// 生产者线程信号量sem_t psem;// 消费者线程信号量sem_t csem;// 互斥锁变量pthread_mutex_t mutex;// 指向头结点的指针struct Node * head = NULL;// 生产者的回调函数void* producer(void* arg)&#123;    // 一直生产    while(1)    &#123;        // 生产者拿一个信号灯        sem_wait(&amp;psem);        // 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁        pthread_mutex_lock(&amp;mutex);        // 创建一个链表的新节点        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));        // 节点初始化        pnew-&gt;number = rand() % 1000;        // 节点的连接, 添加到链表的头部, 新节点就新的头结点        pnew-&gt;next = head;        // head指针前移        head = pnew;        printf(&quot;+++producer, number = %d, tid = %ld\n&quot;, pnew-&gt;number, pthread_self());        pthread_mutex_unlock(&amp;mutex);        // 通知消费者消费        sem_post(&amp;csem);                // 生产慢一点        sleep(rand() % 3);    &#125;    return NULL;&#125;// 消费者的回调函数void* consumer(void* arg)&#123;    while(1)    &#123;        sem_wait(&amp;csem);        pthread_mutex_lock(&amp;mutex);        struct Node* pnode = head;        printf(&quot;--consumer: number: %d, tid = %ld\n&quot;, pnode-&gt;number, pthread_self());        head  = pnode-&gt;next;        // 取出链表的头结点, 将其删除        free(pnode);        pthread_mutex_unlock(&amp;mutex);        // 通知生产者生成, 给生产者加信号灯        sem_post(&amp;psem);        sleep(rand() % 3);    &#125;    return NULL;&#125;int main()&#123;    // 初始化信号量    sem_init(&amp;psem, 0, 5);  // 生成者线程一共有5个信号灯    sem_init(&amp;csem, 0, 0);  // 消费者线程一共有0个信号灯    // 初始化互斥锁    pthread_mutex_init(&amp;mutex, NULL);    // 创建5个生产者, 5个消费者    pthread_t ptid[5];    pthread_t ctid[5];    for(int i=0; i&lt;5; ++i)    &#123;        pthread_create(&amp;ptid[i], NULL, producer, NULL);    &#125;    for(int i=0; i&lt;5; ++i)    &#123;        pthread_create(&amp;ctid[i], NULL, consumer, NULL);    &#125;    // 释放资源    for(int i=0; i&lt;5; ++i)    &#123;        pthread_join(ptid[i], NULL);    &#125;    for(int i=0; i&lt;5; ++i)    &#123;        pthread_join(ctid[i], NULL);    &#125;    sem_destroy(&amp;psem);    sem_destroy(&amp;csem);    pthread_mutex_destroy(&amp;mutex);    return 0;&#125;//作者: 苏丙榅//链接: https://subingwen.cn/linux/thread-sync///来源: 爱编程的大丙//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><pre><code class="c">// 消费者sem_wait(&amp;csem);pthread_mutex_lock(&amp;mutex);// 生产者sem_wait(&amp;csem);pthread_mutex_lock(&amp;mutex);</code></pre><p>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-C语言</title>
      <link href="/2023/09/21/%E7%BA%BF%E7%A8%8B-C%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/09/21/%E7%BA%BF%E7%A8%8B-C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的线程"><a href="#C语言中的线程" class="headerlink" title="C语言中的线程"></a>C语言中的线程</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><ol><li><p>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p></li><li><p>进程和线程的区别：</p><ul><li><p>进程有自己独立的地址空间，多个线程共用同一个地址空间。</p><ul><li><p>在一个地址空间中，多个线程独享：栈区，寄存器。</p></li><li><p>在一个地址空间中，多个线程共享：代码区，堆区，全局数据区，打开的文件。</p></li></ul></li><li><p>线程是程序的最小执行单元，进程是最小的资源分配单位。</p></li><li><p>CPU的调度和切换：线程的上下文切换比进程要快的多。</p></li><li><p>线程更加廉价，启动速度快，退出快，对系统资源的冲击小。</p></li></ul></li></ol><h2 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h2><pre><code class="c++">phread_t phread_self(void); //线程函数，返回当前线程的ID</code></pre><pre><code class="c">#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr,                   void *(*start_routine) (void *), void *arg);// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</code></pre><ul><li>虚拟地址空间的生命周期和主线程是一样的，与子线程无关。</li><li>sleep（）：可以让主线程挂起，让子线程执行完毕，主线程再退出。</li></ul><h2 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h2><pre><code class="c++">#include&lt;pthread.h&gt;void phtread_eixt(void *retval);//只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。//主线程调用退出函数退出, 地址空间不会被释放</code></pre><h2 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h2><blockquote><p>子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做<code> pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p></blockquote><h3 id="4-1-回收子线程数据"><a href="#4-1-回收子线程数据" class="headerlink" title="4.1 回收子线程数据"></a>4.1 回收子线程数据</h3><ul><li><p>使用子线程栈 ：</p><pre><code class="c++">pthread_exit(&amp;p); //子线程退出pthread_join(tid, &amp;ptr); //主线程回收子线程资源，通过ptr void*类型指针传出子线程数据。</code></pre></li><li><p>使用全局变量</p><ul><li>位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是<strong>可以共享全局数据区和堆区数据</strong>，因此在子线程退出的时候可以将<strong>传出数据存储到全局变量、静态变量或者堆内存</strong>中。</li></ul></li><li><p>使用主线程栈</p></li></ul><h2 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h2><pre><code class="c++">#include &lt;pthread.h&gt;// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了int pthread_detach(pthread_t thread);</code></pre><ul><li><p>调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 <code>pthread_join()</code> 就回收不到子线程资源了。</p></li><li><p>为何使用线程分离：因为主线程有自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code> pthread_join()</code> 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p></li></ul><h2 id="6-其他线程函数"><a href="#6-其他线程函数" class="headerlink" title="6. 其他线程函数"></a>6. 其他线程函数</h2><ul><li><p>线程取消</p><pre><code class="c">#include&lt;pthread.h&gt;int pthread_cancel(pthread_t, thread);</code></pre><blockquote><p>使用这个函数杀死一个线程需要分两步：</p><p>在线程 A 中调用线程取消函数 <code>pthread_cancel</code>，指定杀死线程 B，这时候线程 B 是死不了的<br>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。</p></blockquote></li><li><p>线程ID比较</p><ul><li><p>在 Linux 中线程 ID 本质就是一个无符号长整形，在某些平台上<code>pthread_t</code>可能不是一个单纯的整形，这种情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下</p><pre><code class="c">#include &lt;pthread.h&gt;int pthread_equal(pthread_t t1, pthread_t t2);</code></pre><blockquote><p>参数：t1 和 t2 是要比较的线程的线程 ID<br>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</p></blockquote></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式云盘</title>
      <link href="/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E7%9B%98/"/>
      <url>/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/../%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%9B%98/1.png" alt="1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/09/21/MySQL/"/>
      <url>/2023/09/21/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="第1-5章"><a href="#第1-5章" class="headerlink" title="第1-5章"></a>第1-5章</h1><h1 id="基础的一些指令"><a href="#基础的一些指令" class="headerlink" title="基础的一些指令"></a>基础的一些指令</h1><span id="more"></span><pre><code class="mysql">#启动mysqlnet start mysql80#停止mysqlnet stop mysql80#登录mysqlmysql -uroot -pabc123#选择数据库use mydatabase;#显示数据库show mydatabase;#显示数据库中的可用表showtables;#检索单个列select prod_name from products;#检索多个列select prod_id, prod_name, prod_price from products;#检索所有列select*from products#检索不同行select vend_id from products;#DISTINCT 关键字， 指示MySQL只返回不同的值select DINSTINCT vend_id from products;#limit 5指示MYSQL返回不多于5行select prod_name from products limit5;#LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数select prod_name from products limit5,5;#使用完全限定的列名select products.prod_namefrom products;#使用完全限定的表名select products.prod_namefrom crashcourse.products;</code></pre><h1 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h1><ul><li>使用WHERE子句,指定搜索条件进行过滤</li></ul><pre><code class="mysql">select prod_name, prod_price from poducts where prod_price = 2.50;</code></pre><ul><li><ul><li>这条语句从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行。</li></ul></li><li><p>WHERE子句操作符</p></li></ul><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定的两个值之间</td></tr></tbody></table><ul><li>检索单个值</li></ul><pre><code class="mysql">select  prod_name, prod_price from products where prod_name = &#39;fuses&#39;;</code></pre><ul><li><p>何时使用引号 如果仔细观察上述WHERE子句中使用的条件，会看到有的值括在单引号内（如前面使用的’fuses’），而有的值未括起来。单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。</p></li><li><p>范围值检查</p></li></ul><pre><code class="mysql">select prod_name, prod_price from products where prod_price between 5 and 10;</code></pre><p>这两个值必须用AND关键字分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。</p><ul><li>控制检查 NULL</li></ul><pre><code class="mysql">select cust_id from customers where cust_email IS NULL;</code></pre><h1 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h1><ul><li>组合where子句</li></ul><pre><code class="mysql">select prod_id, prod_price, prod_name from products where vend_id = 1003 and prod_price &lt;= 10;select prod_id, prod_price, prod_name from products where vend_id = 1002 or prod_price = 1003;</code></pre><ul><li>计算次序</li></ul><p>SQL中，AND比OR的操作符优先级更高，使用时注意加括号。</p><pre><code class="mysql">select prod_name, prod_price from productswhere (vend_id = 1002 or vend_id = 1003) and prod_price &gt;= 10;</code></pre><ul><li>IN操作符</li></ul><p>IN取合法值的由逗号分号的清单，全都括在圆括号中。</p><pre><code class="mysql">SELECT prod_name, prod_id FROM productsWHERE vend_id IN (1002, 1003)ORDER BY prod_name;</code></pre><ul><li><p>为什么要使用IN操作符？其优点具体如下。</p></li><li><ul><li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li><li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li><li>IN操作符一般比OR操作符清单执行更快。</li><li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。第14章将对此进行详细介绍。</li></ul></li><li><p>IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当。</p></li><li><p>NOT操作符</p></li></ul><p>否定它之后所跟的任何条件</p><pre><code class="mysql">SELECT prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002, 1003)ORDER BY prod_name;</code></pre><ul><li><ul><li>为什么使用NOT？对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单</li></ul></li></ul><h1 id="8-用通配符进行过滤"><a href="#8-用通配符进行过滤" class="headerlink" title="8  用通配符进行过滤"></a>8  用通配符进行过滤</h1><ul><li><em>*<em>*</em>*谓词****</em>*    操作符在它作为谓词时，不是操作符。</li></ul><h2 id="1-百分号（-）通配符"><a href="#1-百分号（-）通配符" class="headerlink" title="***1.百分号（%）通配符*****"></a><em>*<em>*</em>*1.百分号（%）通配符****</em>*</h2><ul><li>% 表任何字符出现任意次数。</li></ul><pre><code class="mysql">SELECT prod_id, prod_nameFrom productsWHERE prod_name LIKE&#39;jet%&#39;;</code></pre><ul><li><ul><li>区分大小写</li></ul></li></ul><pre><code class="mysql">• SELECT prod_id, prod_nameFrom productsWHERE prod_name LIKE&#39;%anvil%&#39;;SELECT prod_id, prod_nameFrom productsWHERE prod_name LIKE&#39;s%e&#39;;#找s起头e结尾的产品    ◦ % 不能匹配NULL值作为产品名的行。</code></pre><h2 id="2-下划线（-）-通配符"><a href="#2-下划线（-）-通配符" class="headerlink" title="2.下划线（_） 通配符"></a>2.下划线（_） 通配符</h2><ul><li>只能匹配单个字符</li></ul><pre><code class="mysql">SELECT prod_id, prod_nameFrom productsWHERE prod_name LIKE&#39;_ton anvil&#39;;</code></pre><h1 id="9章-用正则表达式进行搜索"><a href="#9章-用正则表达式进行搜索" class="headerlink" title="9章 用正则表达式进行搜索"></a>9章 用正则表达式进行搜索</h1><ul><li>正则表达式是用来匹配文本的特殊的串（字符集合）</li></ul><pre><code class="mysql">SELECT prod_nameFROM productsWHERE prod_name REGEXP&#39;1000&#39;ORDERBY prod_name;SELECT prod_nameFROM productsWHERE prod_name REGEXP&#39;.000&#39;#.是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，1000和2000都匹配且返回。ORDERBY prod_name;/*如果 regexp 需要匹配整个字段, 最好使用^$     重要区别like 整个字段匹配表达式成功才返回regexp 部分字符匹配表达式成功即可返回*/#进行OR匹配SELECT prod_nameFROM productswhere prod_name regexp&#39;1000|2000&#39;orderby prod_name;select prod_namefrom prodcutswhere prod_name regexp&#39;[123] Ton&#39;orderby prod_name;select prod_namefrom prodcutswhere prod_name regexp&#39;[^123] Ton&#39;orderby prod_name;#匹配范围select prod_name from products where prod_name regexp&#39;[1-5] Ton&#39;orderby prod_name;#匹配特殊字符select vend_name from vendors where vend_name regexp&#39;\\.&#39;orderby vend_name;#匹配字符类#匹配多个实例select prod_name from products where prod_name regexp&#39;\\([0-9] sticks?\\)&#39;orderby prod_name;#匹配连在一起的4位数字：select prod_name from products where prod_name regexp&#39;[[:digit:]]&#123;4&#125;&#39;orderby prod_name;select prod_name from products where prod_name regexp&#39;[0-9][0-9][0-9][0-9]&#39;orderby prod_name;#定位符/*^匹配串的开始。因此，^[0-9\\.]只在.或任意数字为串中第一个字符时才匹配它们。没有^，则还要多检索出4个别的行（那些中间有数字的行）。*/select prod_name from products where prod_name regexp&#39;^[0-9\\.]&#39;</code></pre><h1 id="10创建计算字段"><a href="#10创建计算字段" class="headerlink" title="10创建计算字段"></a>10创建计算字段</h1><pre><code class="mysql">select Concat(vend_name,&#39; (&#39;, vend_country,&#39;)&#39;)from vendors orderby vend_name;select concat(rtrim(vend_name),&#39; (&#39;, rtrim(vend_country),&#39;)&#39;)from vendors orderby vend_name;select concat(rtrim(vend_name),&#39; (&#39;, rtrim(vend_country),&#39;)&#39;)as vend_title from vendors by vend_name;select prod_id, quantity, item_price from orderitems where order_num =20005;select prod_id, quantity, item_price, quantity*item_price as expanded_price from orderitems where order_num =20005;</code></pre><h1 id="11使用数据处理函数"><a href="#11使用数据处理函数" class="headerlink" title="11使用数据处理函数"></a>11使用数据处理函数</h1><pre><code class="mysql">select vend_name, Upper(vend_name)as vend_name_upcase from vendors orderby vend_name;select cust_name, cust_contact from customers where soundex(cust_contact)= soundex(&#39;Y Lie&#39;);select cust_id, order_num from orders where order_date =&#39;2005-09-01&#39;;#不可靠select cust_id, order_num from orders whereDate(order_date)=&#39;2005-09-01&#39;;select cust_id, order_num from orders whereDate(order_date)between&#39;2005-09-01&#39;and&#39;2005-09-30&#39;;select cust_id, order_num from orders whereyear(oredr_date)=2005and month(order_data)=9;</code></pre><h1 id="12-汇总数据"><a href="#12-汇总数据" class="headerlink" title="12 汇总数据"></a>12 汇总数据</h1><pre><code class="mysql">selectavg(prod_price)as avg_price from products where vend_id =1003;selectcount(*)as num_cust from customers;#* 不省略NULLselectcount(cust_email)as num_cust from customers;selectmax(prod_price)as max_price from products;selectmin(prod_price)as min_price from products;selectsum(quanity)as items_ordered from orderitems where order_num =20005;selectsum(item_price*quantity)as total_price from orderitems where order_num =20005;selectavg(distinct prod_price)as avg_price from products where vend_id =1003;selectcount(*)as num_items,min(prod_price)as price_min,max(prod_price)as price_max,avg(prod_price)as price_avg from products;</code></pre><h1 id="13-分组数据"><a href="#13-分组数据" class="headerlink" title="13 分组数据"></a>13 分组数据</h1><pre><code class="mysql">selectcount(*)as num_prods from products where vend_id =1003;select vend_id,count(*)as num_prods from products groupby vend_id;select cust_id,count(*)as orders from orders groupby cust_id havingcount(*)&gt;=2;select vend_id,count(*)as nums_prods from products where prod_price &gt;=10groupby vend_id havingcount(*)&gt;=2;select order_num,sum(quantity*item_price)as ordertotal from orderitems groupby order_num havingsum(quantity*item_price)&gt;=50orderby ordertotal;</code></pre><h1 id="14-使用子查询"><a href="#14-使用子查询" class="headerlink" title="14 使用子查询"></a>14 使用子查询</h1><pre><code class="mysql">select cust_id from orders where order_num IN(select order_num from orderitems where prod_id =&#39;TNT2&#39;);select cust_name, cust_contact from customers where cust_id IN(10001,10004);select cust_name, cust_contact from customerswhere cust_id in(select cust_id from orders where order_num in(select order_num from orderitems where prod_id =&#39;TNT2&#39;));select cust_name, cust_state,(selectcount(*)from orders whereorder.cust_id= customers.cust_id)as orders from customers orderby cust_name;</code></pre><h1 id="15-联结表"><a href="#15-联结表" class="headerlink" title="15 联结表"></a>15 联结表</h1><pre><code class="mysql">select vend_name, prod_name, prod_price from vendors, productswhere vendors.vend_id= products.vend_idorderby vend_name, prod_name;select vend_name, pord_name, prod_pricefrom vendors innerjoin products on vendors.vend_id= products.vend_id;# 联结多个表tselect prod_name, vend_name, prod_price, quantityfrom orderitems, products, vendorswhere products.vend_id= vendors.vend_idand orderitems.prod_id= products.prod_idand order_num =20005;</code></pre><h1 id="16-创建高级联表"><a href="#16-创建高级联表" class="headerlink" title="16 创建高级联表"></a>16 创建高级联表</h1><pre><code class="mysql">select cust_name, cust_contact from customers as c, orders as o, orderitems as oiwhere c.cust_id= o.cust_idand oi.order= o.cust_id  and prod_id =&#39;TNT2&#39;;#自联结select prod_id, prod_name from products where vend_id =(select vend_id from products where prod_id =&#39;DTNTR&#39;);select p1.priod_id, p1.prod_namefrom products as p1, products as p2 where p1.vend_id= p2.vend_idand  p2.prod_id=&#39;DTNTR&#39;;#自然联结select c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, OI.item_pricefrom customers as c, orders as o, orderitems as oiwhere c.cust_id= o.cust_idand oi.order_num= o.order_numand prod_id =&#39;FB&#39;;#外部联结select customers.cust_id, orders.order_numfrom customers leftouterjoinorders on customers.cust_id= orders.cust_id;select custmoers.cust_name, customers.cust_id,count(order.order_num)as num_ordfrom customers innerjoin orders on customers.cust_Id= orders.cust_idgroupby customers.cust_id;</code></pre><h1 id="17-组合查询"><a href="#17-组合查询" class="headerlink" title="17 组合查询"></a>17 组合查询</h1><pre><code class="mysql">select vend_id, prod_id, prod_price from products where prod_price &lt;=5unionselect vend_id, prod_id, prod_price from products where vend_id IN(1001,1002);select vend_id, prod_id, prod_price from products where prod_price &lt;=5unionall##MySql不取消重复的行。select vend_id, prod_id, prod_price from products where vend_id in(1001,1002);#在用union组合查询时，只能使用一条order by 子句，必须出现在最后一条select语句之后。</code></pre><h1 id="18-全文本搜索"><a href="#18-全文本搜索" class="headerlink" title="18 全文本搜索"></a>18 全文本搜索</h1><pre><code class="mysql">select note_text from productnotes wherematch(note_text) against(&#39;rabbit&#39;);select note_text from productnotes where note_text like&#39;%rabbit%&#39;;#使用查询扩展select note_textfrom productnotes wherematch(note_text) against(&#39;anvils&#39;withquery expansion);#布尔文本搜索select note_text from productnotes wherematch(note_text) against(&#39;heavy&#39;,in boolen mode);select note_text from productnotes wherematch(note_text) against(&#39;heavy -rope*&#39;inbooleanmode);select note_text from productnotes wherematch(note_text) against(&#39;+rabbit + bait&#39;in boolen mode);select note_text from productnotes wherematch(note_text) against(&#39;rabbit bait&#39;in boolen mode);select note_text from productnotes wherematch(note_text) against(&#39;&quot;rabbit bait&quot;&#39;in boolen mode);select note_text from productnotes wherematch(note_text) against(&#39;&gt;rabbit &lt;carrot&#39;in boolen mode);select note_text from productnotes wherematch(note_text) against(&#39;+safe +(&lt;combination)&#39;in boolen mode);</code></pre><h1 id="19-数据插入"><a href="#19-数据插入" class="headerlink" title="19 数据插入"></a>19 数据插入</h1><pre><code class="mysql"># 插入完整行insertinto customers values(null,                            &#39;a&#39;,                            &#39;b&#39;,                            &#39;c&#39;,                            null,                            null);#这种写法不安全insertinto customers(cust_name,                      cust_address,                      cust_state,                      cust_zip,                      cust_country                      ....)                      values(&#39;a&#39;,                            ...); insertinto customers(cust_id, cust_contact, cust_email, cust_name, ...)select cust_id, cust_contact,...from custnew;</code></pre><h1 id="20-更新和删除数据"><a href="#20-更新和删除数据" class="headerlink" title="20 更新和删除数据"></a>20 更新和删除数据</h1><pre><code class="mysql">#update语句由3部分组成：#要更新的表#列名和它们的新值：#确定要更新行的过滤条件。update customers set cust_email =&#39;elmer@fudd.com&#39;where cust_id =10005;update customers set cust_name =&#39;the fudds&#39;,    cust_email =&#39;elmer@fudd.com&#39;where cust_id =10005;update customers set cust_email =nullwhere cust_id =10005;deletefrom customers where cust_id =10006;# 如果省略where子句，它将删除表中每个客户# 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。#在对update或delete语句where子句前，应该先用selete进行测试，保证它过滤的是正确的记录，以防编写where子句不正确。</code></pre><h1 id="21-创建和操纵表"><a href="#21-创建和操纵表" class="headerlink" title="21 创建和操纵表"></a>21 创建和操纵表</h1><pre><code class="mysql">createtable customers(    cust_id         int         notnullauto_increment,    cust_name       char(50)    notnull,    cust_address    char(50)    null,    cust_city       char(50)    null,    ...)engine=innodb;#指定默认值createtable orderitems(    order_num   int     notnull,    order_item  int     notnull,    prod_id     char(10)    notnull,    quantity    int     notnulldefault1,# 未给出数量时，使用数量1.    item_price  decimal(8,2)    notnull,    primarykey(order_num, order_item))engine=innodb;#引擎类型#innodb：一个可靠的事务处理引擎，不支持全文本搜索#memory:功能等同于myisam， 但由于数据存储在内存中，速度很快#myisam：一个性能极高的引擎，支持全文本搜索，但不支持事务处理altertable vendors add vend_phone char(20);#给表vendors增加一个名为vend_phone的列， 明确数据类型。altertable vendors dropcolumn vend_phone;#删除列#删除表 永久droptable customers2;#重命名renametable customers2 to customers;</code></pre><h1 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22 使用视图"></a>22 使用视图</h1><pre><code class="mysql">#视图是一个虚拟的表，帮助我们不必了解表的创建和表的联结，也可以查询我们想要的数据。#视图仅仅是用来查看存储在别处的数据的一种设施，视图本身不包含数据，因此他们返回的数据是从其他表中检索出来的。#在添加或更改这些表中的数据时，视图将返回改变过的数据。#利用视图简化复杂的联结createview productcustomers asselect cust_name, cust_contact, prod_id from customers, orders,orderitems where customers.cust_id= orders.cust_idand orderitems.order_num= orders.order_num;select cust_name, cust_contact from productcustomers where prod_id =&#39;TNT2&#39;;#视图极大地简化了复杂SQL语句的使用，利用视图，可一次性编写基础SQL，然后根据需要多次使用。#用视图重新格式化检索出的数据select concat(RTrim(vend_name),&#39; (&#39;, RTrim(vend_country),&#39;)&#39;)as vend_title from vendors orderby vend_name;createview vendorlocations asselect concat(RTrim(vend_name),&#39; (&#39;, RTrim(vend_country),&#39;)&#39;)as vend_title from vendors orderby vend_name;#过滤createview customeremaillist asselect cust_id. cust_name, cust_email from customers where cust_email isnotnull;#createview orderitemsexpanded asselect order_num, prod_id, quantity, item_price,            quantity*item_price as expanded_price from orderitems;select*from orderitemsexpanded where order_num =20005;#视图应该用于检索而不是更新。</code></pre><h1 id="23使用存储过程"><a href="#23使用存储过程" class="headerlink" title="23使用存储过程"></a>23使用存储过程</h1><pre><code class="mysql">#执行存储过程call productpricing(@pricelow,                  @pricehigh,                    @priceaverage);#创建存储过程                     createprocedure productpricing()begin    selectavg(prod_price)as priceaverage    from products;end;call productpricing();dropprocedure productpricing;#使用参数createprocedure productpricing(    out p1 decimal(8,1),    out ph decimal(8,2),    out pa decimal(8,2),)begin    selectmin(prod_price)    into p1    from product;    selectmax(prod_price)    into ph    from product;    selectavg(prod_price)    into pa    from product;end;##call productpricing(@pricelow,                   @pricehigh,                   @priceaverage);# 所有mysql变量都必须以@开始select@priceaverage;##select@pricehigh,@pricelow,@priceaverage;##createprocedure ordertotal(    in onumber int,        #传入存储过程    out ototal decimal(8,2) #传出存储过程)begin    selectsum(item_price*quantity)    from orderitems    where order_num = onumber    into ototal;end;##call ordertotal(20005,@total);select@total;# 检查存储过程showcreateprocedure ordertotal;</code></pre><h1 id="24-使用游标"><a href="#24-使用游标" class="headerlink" title="24 使用游标"></a>24 使用游标</h1><ul><li>游标是一个存存储在Mysql服务器上的数据库查询，他不是一条select语句，而是被语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</li></ul><pre><code class="mysql">createprocedure processorders()begin    declare ordernumbers cursorforselect order_num from orders;end;#declare (声明)语句用来定义和命名游标open ordernumbers;close ordernumbers;##createprocedure processorders()begin    declare the cursor    for    select order_num from orders;        open ordernumbers;    fetch ordernumbers into o;    close ordernumbers;end;##createprocedure processorders()begin    declare done boolen default0;    declare o int;    declare t decimal(8,2);    declare ordernumbers cursorforselect order_num from orders;    declarecontinuehandlerforsqlstate&#39;02000&#39;set done =1;        createtableifnotexists ordertotals (order_num int, total decimal(8,2));        open ordernumbers;        repeat        fetch ordernumbers into o;                call ordertotal(o,1, t);                -- insert order and total into ordertotals        insertinto ordertotals(order_num, total)values(o, t);        until done endrepeat;        close ordernumbers;end;##  </code></pre><p>​    </p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
