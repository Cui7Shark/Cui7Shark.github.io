<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程同步</title>
      <link href="/2023/09/21/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/09/21/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的线程同步"><a href="#C语言中的线程同步" class="headerlink" title="C语言中的线程同步"></a>C语言中的线程同步</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>当一个线程对内存中的共享资源进行访问的时候，其他线程都不可以操作这块内存，直到线程 A 对这块内存访问完毕为止。</p><h2 id="2-为什么要实现线程同步"><a href="#2-为什么要实现线程同步" class="headerlink" title="2 为什么要实现线程同步"></a>2 为什么要实现线程同步</h2><p>为了使多个线程操作同一个全局变量的时候，全局变量的数据被及时正确的读取、计算、写入内存中，保证程序正确的执行下去。</p><h2 id="3-同步方式"><a href="#3-同步方式" class="headerlink" title="3 同步方式"></a>3 同步方式</h2><ul><li>互斥锁 </li><li>读写锁</li><li>条件变量</li><li>信号量</li></ul><blockquote><p>所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为临界资源。</p></blockquote><p><img src="/../%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/image-20200106092600543.png" alt="image-20200106092600543"></p><ul><li>临界区上边上锁，下边解锁</li></ul><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1. 互斥锁"></a>1. 互斥锁</h3><ul><li><p>通过互斥锁可以锁定一个代码块，</p></li><li><p>被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要<strong>付出的代价就是执行效率的降低</strong>，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p></li><li><p>创建一把互斥锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数:</span></span><br><span class="line"><span class="comment">//mutex: 互斥锁变量的地址</span></span><br><span class="line"><span class="comment">//attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</span></span><br></pre></td></tr></table></figure></li><li><p>上锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure></li><li><p>尝试加锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(pthread_mutex* mutex)</span>;</span><br><span class="line"><span class="comment">//如果锁变量是锁定的，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号。</span></span><br></pre></td></tr></table></figure></li><li><p>解锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(pthread_mutex* mutex)</span>;</span><br><span class="line"><span class="comment">//不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>死锁</strong>：锁使用不当，如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有：</p><ul><li><p>加锁后忘记解锁</p></li><li><p>重复加锁，造成死锁</p></li><li><p>程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">场景描述:</span><br><span class="line">  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B</span><br><span class="line">     - 线程A访问资源X, 加锁A</span><br><span class="line">     - 线程B访问资源Y, 加锁B</span><br><span class="line">  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞</span><br><span class="line">     - 线程A被锁B阻塞了, 无法打开A锁</span><br><span class="line">     - 线程B被锁A阻塞了, 无法打开B锁</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="2-读写锁-–-是互斥锁的升级版"><a href="#2-读写锁-–-是互斥锁的升级版" class="headerlink" title="2. 读写锁  – (是互斥锁的升级版)"></a>2. 读写锁  – (是互斥锁的升级版)</h3><ul><li><p>创建 ：<code>pthread_rwlock_t rwlock;</code> </p></li><li><p>在<strong>做读操作的时候可以提高程序的执行效率</strong>，如果所有的线程都是做读操作, 那么读是并行的</p></li><li><p>如果读写锁锁定了读操作，需要先解锁才能锁定写操作，反之亦然。</p></li><li><p>读写锁的特点：</p><ol><li>读锁是共享的</li><li>写锁是独占的</li><li>写锁比读锁的优先级高。</li></ol></li></ul><blockquote><p>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源<strong>读的操作越多，读写锁更有优势</strong>。</p></blockquote><ul><li><ul><li>读写锁是一把锁， 锁定了读操作，就不能锁定写操作了，不能同时锁定。</li></ul></li><li>读写锁的操作函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">//初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">//attr: 读写锁属性，一般使用默认属性，指定为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlocck)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlocck)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h3><p><strong>条件变量的主要作用不是处理线程同步，而是进行线程的阻塞</strong>。<strong>在多线程程序中，条件变量需要配合互斥锁来使用。</strong></p><p>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</p><p><strong>分工</strong>：互斥锁用来做线程同步；条件变量用来阻塞线程的。</p><ul><li>条件变量的操作函数如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* <span class="keyword">restrict</span> attr)</span>;<span class="comment">//att 指定为NULL</span></span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><h4 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h4><p><img src="/../%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/1564644834918.png" alt="1564644834918"></p><p>生产者和消费者模型的组成：</p><ol><li>生产者线程 -&gt; 若干个<ol><li>生产商品或者任务放入到任务队列中</li><li>任务队列满了就阻塞，不满的时候就工作</li><li>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</li></ol></li><li>消费者线程 -&gt; 若干个<ol><li>读任务队列，将任务或者数据取出</li><li>任务队列中有数据就消费，没有数据就阻塞</li><li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li></ol></li><li>队列-&gt;存储任务 &#x2F; 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存<ul><li>可以是数组、链表，也可以使用 <code>stl</code>容器：<code>queue / stack / list / vector</code></li></ul></li></ol><h3 id="4-信号量–-用起来比条件变量简单"><a href="#4-信号量–-用起来比条件变量简单" class="headerlink" title="4. 信号量–  用起来比条件变量简单"></a>4. 信号量–  用起来比条件变量简单</h3><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。<strong>信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</strong></p><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为 <code>&lt;semaphore.h&gt;：</code></p><p>信号量操作函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建信号量</span></span><br><span class="line"><span class="type">sem_t</span> sem1;</span><br><span class="line"><span class="type">sem_t</span> sem2;</span><br><span class="line"><span class="comment">//初始化信号量/灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数       </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数:<br><code>sem</code>：信号量变量地址<br><code>pshared</code>：<br>0：线程同步<br>非 0：进程同步<br>value：初始化当前信号量拥有的资源数（&gt;&#x3D;0），如果资源数为 0，线程就会被阻塞了.</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">// sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号</span></span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line"><span class="comment">//查看信号量sem中的整型数的当前值，个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span>* sval)</span>;</span><br></pre></td></tr></table></figure><h4 id="总资源数为1"><a href="#总资源数为1" class="headerlink" title="总资源数为1"></a>总资源数为1</h4><p>如果生产者和消费者使用的信号量总资源数为 1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p><h4 id="总资源数大于-1"><a href="#总资源数大于-1" class="headerlink" title="总资源数大于 1"></a><strong>总资源数大于 1</strong></h4><p><strong>为防止共享资源出现数据混乱，需要使用互斥锁进行线程同步。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//作者: 苏丙榅</span></span><br><span class="line"><span class="comment">//链接: https://subingwen.cn/linux/thread-sync/</span></span><br><span class="line"><span class="comment">//来源: 爱编程的大丙</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-C语言</title>
      <link href="/2023/09/21/%E7%BA%BF%E7%A8%8B-C%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/09/21/%E7%BA%BF%E7%A8%8B-C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的线程"><a href="#C语言中的线程" class="headerlink" title="C语言中的线程"></a>C语言中的线程</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><ol><li><p>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p></li><li><p>进程和线程的区别：</p><ul><li><p>进程有自己独立的地址空间，多个线程共用同一个地址空间。</p><ul><li><p>在一个地址空间中，多个线程独享：栈区，寄存器。</p></li><li><p>在一个地址空间中，多个线程共享：代码区，堆区，全局数据区，打开的文件。</p></li></ul></li><li><p>线程是程序的最小执行单元，进程是最小的资源分配单位。</p></li><li><p>CPU的调度和切换：线程的上下文切换比进程要快的多。</p></li><li><p>线程更加廉价，启动速度快，退出快，对系统资源的冲击小。</p></li></ul></li></ol><h2 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">phread_t</span> <span class="title">phread_self</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//线程函数，返回当前线程的ID</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</span></span><br></pre></td></tr></table></figure><ul><li>虚拟地址空间的生命周期和主线程是一样的，与子线程无关。</li><li>sleep（）：可以让主线程挂起，让子线程执行完毕，主线程再退出。</li></ul><h2 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">phtread_eixt</span><span class="params">(<span class="type">void</span> *retval)</span></span>;<span class="comment">//只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。</span></span><br><span class="line"><span class="comment">//主线程调用退出函数退出, 地址空间不会被释放</span></span><br></pre></td></tr></table></figure><h2 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h2><blockquote><p>子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做<code> pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p></blockquote><h3 id="4-1-回收子线程数据"><a href="#4-1-回收子线程数据" class="headerlink" title="4.1 回收子线程数据"></a>4.1 回收子线程数据</h3><ul><li><p>使用子线程栈 ：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_exit</span>(&amp;p); <span class="comment">//子线程退出</span></span><br><span class="line"><span class="built_in">pthread_join</span>(tid, &amp;ptr); <span class="comment">//主线程回收子线程资源，通过ptr void*类型指针传出子线程数据。</span></span><br></pre></td></tr></table></figure></li><li><p>使用全局变量</p><ul><li>位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是<strong>可以共享全局数据区和堆区数据</strong>，因此在子线程退出的时候可以将<strong>传出数据存储到全局变量、静态变量或者堆内存</strong>中。</li></ul></li><li><p>使用主线程栈</p></li></ul><h2 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 <code>pthread_join()</code> 就回收不到子线程资源了。</p></li><li><p>为何使用线程分离：因为主线程有自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code> pthread_join()</code> 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p></li></ul><h2 id="6-其他线程函数"><a href="#6-其他线程函数" class="headerlink" title="6. 其他线程函数"></a>6. 其他线程函数</h2><ul><li><p>线程取消</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span>, thread)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用这个函数杀死一个线程需要分两步：</p><p>在线程 A 中调用线程取消函数 <code>pthread_cancel</code>，指定杀死线程 B，这时候线程 B 是死不了的<br>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。</p></blockquote></li><li><p>线程ID比较</p><ul><li><p>在 Linux 中线程 ID 本质就是一个无符号长整形，在某些平台上<code>pthread_t</code>可能不是一个单纯的整形，这种情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数：t1 和 t2 是要比较的线程的线程 ID<br>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</p></blockquote></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式云盘</title>
      <link href="/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E7%9B%98/"/>
      <url>/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/../%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%9B%98/1.png" alt="1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/09/21/MySQL/"/>
      <url>/2023/09/21/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="第1-5章"><a href="#第1-5章" class="headerlink" title="第1-5章"></a>第1-5章</h1><h1 id="基础的一些指令"><a href="#基础的一些指令" class="headerlink" title="基础的一些指令"></a>基础的一些指令</h1><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动mysql</span><br><span class="line">net start mysql80</span><br><span class="line">#停止mysql</span><br><span class="line">net stop mysql80</span><br><span class="line">#登录mysql</span><br><span class="line">mysql -uroot -pabc123</span><br><span class="line">#选择数据库</span><br><span class="line">use mydatabase;</span><br><span class="line">#显示数据库</span><br><span class="line">show mydatabase;</span><br><span class="line">#显示数据库中的可用表</span><br><span class="line">showtables;</span><br><span class="line">#检索单个列</span><br><span class="line">select prod_name from products;</span><br><span class="line">#检索多个列</span><br><span class="line">select prod_id, prod_name, prod_price from products;</span><br><span class="line">#检索所有列</span><br><span class="line">select*from products</span><br><span class="line">#检索不同行</span><br><span class="line">select vend_id from products;</span><br><span class="line">#DISTINCT 关键字， 指示MySQL只返回不同的值</span><br><span class="line">select DINSTINCT vend_id from products;</span><br><span class="line">#limit 5指示MYSQL返回不多于5行</span><br><span class="line">select prod_name from products limit5;</span><br><span class="line">#LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数</span><br><span class="line">select prod_name from products limit5,5;</span><br><span class="line">#使用完全限定的列名</span><br><span class="line">select products.prod_namefrom products;</span><br><span class="line">#使用完全限定的表名</span><br><span class="line">select products.prod_namefrom crashcourse.products;</span><br></pre></td></tr></table></figure><h1 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h1><ul><li>使用WHERE子句,指定搜索条件进行过滤</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select prod_name, prod_price from poducts where prod_price = 2.50;</span><br></pre></td></tr></table></figure><ul><li><ul><li>这条语句从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行。</li></ul></li><li><p>WHERE子句操作符</p></li></ul><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定的两个值之间</td></tr></tbody></table><ul><li>检索单个值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select  prod_name, prod_price from products where prod_name = &#x27;fuses&#x27;;</span><br></pre></td></tr></table></figure><ul><li><p>何时使用引号 如果仔细观察上述WHERE子句中使用的条件，会看到有的值括在单引号内（如前面使用的’fuses’），而有的值未括起来。单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。</p></li><li><p>范围值检查</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select prod_name, prod_price from products where prod_price between 5 and 10;</span><br></pre></td></tr></table></figure><p>这两个值必须用AND关键字分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。</p><ul><li>控制检查 NULL</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select cust_id from customers where cust_email IS NULL;</span><br></pre></td></tr></table></figure><h1 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h1><ul><li>组合where子句</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select prod_id, prod_price, prod_name from products where vend_id = 1003 and </span><br><span class="line">prod_price &lt;= 10;</span><br><span class="line"></span><br><span class="line">select prod_id, prod_price, prod_name from products where vend_id = 1002 or </span><br><span class="line">prod_price = 1003;</span><br></pre></td></tr></table></figure><ul><li>计算次序</li></ul><p>SQL中，AND比OR的操作符优先级更高，使用时注意加括号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select prod_name, prod_price from products</span><br><span class="line">where (vend_id = 1002 or vend_id = 1003) and prod_price &gt;= 10;</span><br></pre></td></tr></table></figure><ul><li>IN操作符</li></ul><p>IN取合法值的由逗号分号的清单，全都括在圆括号中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_id FROM products</span><br><span class="line">WHERE vend_id IN (1002, 1003)</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure><ul><li><p>为什么要使用IN操作符？其优点具体如下。</p></li><li><ul><li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li><li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li><li>IN操作符一般比OR操作符清单执行更快。</li><li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。第14章将对此进行详细介绍。</li></ul></li><li><p>IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当。</p></li><li><p>NOT操作符</p></li></ul><p>否定它之后所跟的任何条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id NOT IN (1002, 1003)</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure><ul><li><ul><li>为什么使用NOT？对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单</li></ul></li></ul><h1 id="8-用通配符进行过滤"><a href="#8-用通配符进行过滤" class="headerlink" title="8  用通配符进行过滤"></a>8  用通配符进行过滤</h1><ul><li><em>*<em>*</em>*谓词****</em>*    操作符在它作为谓词时，不是操作符。</li></ul><h2 id="1-百分号（-）通配符"><a href="#1-百分号（-）通配符" class="headerlink" title="***1.百分号（%）通配符*****"></a><em>*<em>*</em>*1.百分号（%）通配符****</em>*</h2><ul><li>% 表任何字符出现任意次数。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_name</span><br><span class="line">From products</span><br><span class="line">WHERE prod_name LIKE&#x27;jet%&#x27;;</span><br></pre></td></tr></table></figure><ul><li><ul><li>区分大小写</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• SELECT prod_id, prod_name</span><br><span class="line">From products</span><br><span class="line">WHERE prod_name LIKE&#x27;%anvil%&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT prod_id, prod_name</span><br><span class="line">From products</span><br><span class="line">WHERE prod_name LIKE&#x27;s%e&#x27;;#找s起头e结尾的产品</span><br><span class="line">    ◦ % 不能匹配NULL值作为产品名的行。</span><br></pre></td></tr></table></figure><h2 id="2-下划线（-）-通配符"><a href="#2-下划线（-）-通配符" class="headerlink" title="2.下划线（_） 通配符"></a>2.下划线（_） 通配符</h2><ul><li>只能匹配单个字符</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_name</span><br><span class="line">From products</span><br><span class="line">WHERE prod_name LIKE&#x27;_ton anvil&#x27;;</span><br></pre></td></tr></table></figure><h1 id="9章-用正则表达式进行搜索"><a href="#9章-用正则表达式进行搜索" class="headerlink" title="9章 用正则表达式进行搜索"></a>9章 用正则表达式进行搜索</h1><ul><li>正则表达式是用来匹配文本的特殊的串（字符集合）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP&#x27;1000&#x27;</span><br><span class="line">ORDERBY prod_name;</span><br><span class="line"></span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP&#x27;.000&#x27;#.是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，1000和2000都匹配且返回。</span><br><span class="line">ORDERBY prod_name;</span><br><span class="line">/*如果 regexp 需要匹配整个字段, 最好使用^$ </span><br><span class="line">    重要区别</span><br><span class="line">like 整个字段匹配表达式成功才返回</span><br><span class="line">regexp 部分字符匹配表达式成功即可返回</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#进行OR匹配</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">where prod_name regexp&#x27;1000|2000&#x27;</span><br><span class="line">orderby prod_name;</span><br><span class="line"></span><br><span class="line">select prod_name</span><br><span class="line">from prodcuts</span><br><span class="line">where prod_name regexp&#x27;[123] Ton&#x27;</span><br><span class="line">orderby prod_name;</span><br><span class="line"></span><br><span class="line">select prod_name</span><br><span class="line">from prodcuts</span><br><span class="line">where prod_name regexp&#x27;[^123] Ton&#x27;</span><br><span class="line">orderby prod_name;</span><br><span class="line"></span><br><span class="line">#匹配范围</span><br><span class="line">select prod_name from products where prod_name regexp&#x27;[1-5] Ton&#x27;orderby prod_name;</span><br><span class="line">#匹配特殊字符</span><br><span class="line">select vend_name from vendors where vend_name regexp&#x27;\\.&#x27;orderby vend_name;</span><br><span class="line">#匹配字符类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#匹配多个实例</span><br><span class="line">select prod_name from products where prod_name regexp&#x27;\\([0-9] sticks?\\)&#x27;orderby prod_name;</span><br><span class="line">#匹配连在一起的4位数字：</span><br><span class="line">select prod_name from products where prod_name regexp&#x27;[[:digit:]]&#123;4&#125;&#x27;orderby prod_name;</span><br><span class="line">select prod_name from products where prod_name regexp&#x27;[0-9][0-9][0-9][0-9]&#x27;orderby prod_name;</span><br><span class="line">#定位符</span><br><span class="line">/*^匹配串的开始。因此，^[0-9\\.]只在.或任意数字为串中第</span><br><span class="line">一个字符时才匹配它们。没有^，则还要多检索出4个别的行（那</span><br><span class="line">些中间有数字的行）。*/</span><br><span class="line">select prod_name from products where prod_name regexp&#x27;^[0-9\\.]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="10创建计算字段"><a href="#10创建计算字段" class="headerlink" title="10创建计算字段"></a>10创建计算字段</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select Concat(vend_name,&#x27; (&#x27;, vend_country,&#x27;)&#x27;)from vendors orderby vend_name;</span><br><span class="line">select concat(rtrim(vend_name),&#x27; (&#x27;, rtrim(vend_country),&#x27;)&#x27;)from vendors orderby vend_name;</span><br><span class="line">select concat(rtrim(vend_name),&#x27; (&#x27;, rtrim(vend_country),&#x27;)&#x27;)as vend_title from vendors by vend_name;</span><br><span class="line">select prod_id, quantity, item_price from orderitems where order_num =20005;</span><br><span class="line">select prod_id, quantity, item_price, quantity*item_price as expanded_price from orderitems where order_num =20005;</span><br></pre></td></tr></table></figure><h1 id="11使用数据处理函数"><a href="#11使用数据处理函数" class="headerlink" title="11使用数据处理函数"></a>11使用数据处理函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select vend_name, Upper(vend_name)as vend_name_upcase from vendors orderby vend_name;</span><br><span class="line">select cust_name, cust_contact from customers where soundex(cust_contact)= soundex(&#x27;Y Lie&#x27;);</span><br><span class="line">select cust_id, order_num from orders where order_date =&#x27;2005-09-01&#x27;;#不可靠</span><br><span class="line">select cust_id, order_num from orders whereDate(order_date)=&#x27;2005-09-01&#x27;;</span><br><span class="line">select cust_id, order_num from orders whereDate(order_date)between&#x27;2005-09-01&#x27;and&#x27;2005-09-30&#x27;;</span><br><span class="line">select cust_id, order_num from orders whereyear(oredr_date)=2005and month(order_data)=9;</span><br></pre></td></tr></table></figure><h1 id="12-汇总数据"><a href="#12-汇总数据" class="headerlink" title="12 汇总数据"></a>12 汇总数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selectavg(prod_price)as avg_price from products where vend_id =1003;</span><br><span class="line">selectcount(*)as num_cust from customers;#* 不省略NULL</span><br><span class="line">selectcount(cust_email)as num_cust from customers;</span><br><span class="line">selectmax(prod_price)as max_price from products;</span><br><span class="line">selectmin(prod_price)as min_price from products;</span><br><span class="line">selectsum(quanity)as items_ordered from orderitems where order_num =20005;</span><br><span class="line">selectsum(item_price*quantity)as total_price from orderitems where order_num =20005;</span><br><span class="line">selectavg(distinct prod_price)as avg_price from products where vend_id =1003;</span><br><span class="line">selectcount(*)as num_items,min(prod_price)as price_min,max(prod_price)as price_max,avg(prod_price)as price_avg from products;</span><br></pre></td></tr></table></figure><h1 id="13-分组数据"><a href="#13-分组数据" class="headerlink" title="13 分组数据"></a>13 分组数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selectcount(*)as num_prods from products where vend_id =1003;</span><br><span class="line">select vend_id,count(*)as num_prods from products groupby vend_id;</span><br><span class="line">select cust_id,count(*)as orders from orders groupby cust_id havingcount(*)&gt;=2;</span><br><span class="line">select vend_id,count(*)as nums_prods from products where prod_price &gt;=10groupby vend_id havingcount(*)&gt;=2;</span><br><span class="line">select order_num,sum(quantity*item_price)as ordertotal from orderitems groupby order_num havingsum(quantity*item_price)&gt;=50</span><br><span class="line">orderby ordertotal;</span><br></pre></td></tr></table></figure><h1 id="14-使用子查询"><a href="#14-使用子查询" class="headerlink" title="14 使用子查询"></a>14 使用子查询</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select cust_id from orders where order_num IN(select order_num from orderitems where prod_id =&#x27;TNT2&#x27;);</span><br><span class="line">select cust_name, cust_contact from customers where cust_id IN(10001,10004);</span><br><span class="line"></span><br><span class="line">select cust_name, cust_contact from customers</span><br><span class="line">where cust_id in</span><br><span class="line">(select cust_id from orders where order_num in</span><br><span class="line">(select order_num from orderitems where prod_id =&#x27;TNT2&#x27;));</span><br><span class="line"></span><br><span class="line">select cust_name, cust_state,(selectcount(*)from orders whereorder.cust_id= customers.cust_id)</span><br><span class="line">as orders from customers orderby cust_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="15-联结表"><a href="#15-联结表" class="headerlink" title="15 联结表"></a>15 联结表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select vend_name, prod_name, prod_price from vendors, products</span><br><span class="line">where vendors.vend_id= products.vend_id</span><br><span class="line">orderby vend_name, prod_name;</span><br><span class="line"></span><br><span class="line">select vend_name, pord_name, prod_price</span><br><span class="line">from vendors innerjoin products on vendors.vend_id= products.vend_id;</span><br><span class="line"></span><br><span class="line"># 联结多个表t</span><br><span class="line">select prod_name, vend_name, prod_price, quantity</span><br><span class="line">from orderitems, products, vendors</span><br><span class="line">where products.vend_id= vendors.vend_id</span><br><span class="line">and orderitems.prod_id= products.prod_id</span><br><span class="line">and order_num =20005;</span><br></pre></td></tr></table></figure><h1 id="16-创建高级联表"><a href="#16-创建高级联表" class="headerlink" title="16 创建高级联表"></a>16 创建高级联表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select cust_name, cust_contact from customers as c, orders as o, orderitems as oi</span><br><span class="line">where c.cust_id= o.cust_idand oi.order= o.cust_id  and prod_id =&#x27;TNT2&#x27;;</span><br><span class="line"></span><br><span class="line">#自联结</span><br><span class="line">select prod_id, prod_name from products where vend_id =(select vend_id from products where prod_id =&#x27;DTNTR&#x27;);</span><br><span class="line"></span><br><span class="line">select p1.priod_id, p1.prod_namefrom products as p1, products as p2 where p1.vend_id= p2.vend_idand  p2.prod_id=&#x27;DTNTR&#x27;;</span><br><span class="line"></span><br><span class="line">#自然联结</span><br><span class="line">select c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, OI.item_price</span><br><span class="line">from customers as c, orders as o, orderitems as oi</span><br><span class="line">where c.cust_id= o.cust_idand oi.order_num= o.order_numand prod_id =&#x27;FB&#x27;;</span><br><span class="line"></span><br><span class="line">#外部联结</span><br><span class="line">select customers.cust_id, orders.order_numfrom customers leftouterjoin</span><br><span class="line">orders on customers.cust_id= orders.cust_id;</span><br><span class="line"></span><br><span class="line">select custmoers.cust_name, customers.cust_id,count(order.order_num)as num_ord</span><br><span class="line">from customers innerjoin orders on customers.cust_Id= orders.cust_idgroupby customers.cust_id;</span><br></pre></td></tr></table></figure><h1 id="17-组合查询"><a href="#17-组合查询" class="headerlink" title="17 组合查询"></a>17 组合查询</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select vend_id, prod_id, prod_price from products where prod_price &lt;=5</span><br><span class="line">union</span><br><span class="line">select vend_id, prod_id, prod_price from products where vend_id IN(1001,1002);</span><br><span class="line"></span><br><span class="line">select vend_id, prod_id, prod_price from products where prod_price &lt;=5</span><br><span class="line">unionall##MySql不取消重复的行。</span><br><span class="line">select vend_id, prod_id, prod_price from products where vend_id in(1001,1002);</span><br><span class="line"></span><br><span class="line">#在用union组合查询时，只能使用一条order by 子句，必须出现在最后一条select语句之后。</span><br></pre></td></tr></table></figure><h1 id="18-全文本搜索"><a href="#18-全文本搜索" class="headerlink" title="18 全文本搜索"></a>18 全文本搜索</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;rabbit&#x27;);</span><br><span class="line">select note_text from productnotes where note_text like&#x27;%rabbit%&#x27;;</span><br><span class="line"></span><br><span class="line">#使用查询扩展</span><br><span class="line">select note_text</span><br><span class="line">from productnotes wherematch(note_text) against(&#x27;anvils&#x27;withquery expansion);</span><br><span class="line"></span><br><span class="line">#布尔文本搜索</span><br><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;heavy&#x27;,in boolen mode);</span><br><span class="line"></span><br><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;heavy -rope*&#x27;inbooleanmode);</span><br><span class="line"></span><br><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;+rabbit + bait&#x27;in boolen mode);</span><br><span class="line"></span><br><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;rabbit bait&#x27;in boolen mode);</span><br><span class="line"></span><br><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;&quot;rabbit bait&quot;&#x27;in boolen mode);</span><br><span class="line"></span><br><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;&gt;rabbit &lt;carrot&#x27;in boolen mode);</span><br><span class="line"></span><br><span class="line">select note_text from productnotes wherematch(note_text) against(&#x27;+safe +(&lt;combination)&#x27;in boolen mode);</span><br></pre></td></tr></table></figure><h1 id="19-数据插入"><a href="#19-数据插入" class="headerlink" title="19 数据插入"></a>19 数据插入</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插入完整行</span><br><span class="line">insertinto customers values(null,</span><br><span class="line">                            &#x27;a&#x27;,</span><br><span class="line">                            &#x27;b&#x27;,</span><br><span class="line">                            &#x27;c&#x27;,</span><br><span class="line">                            null,</span><br><span class="line">                            null);#这种写法不安全</span><br><span class="line"></span><br><span class="line">insertinto customers(cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country</span><br><span class="line">                      ....)</span><br><span class="line">                      values(&#x27;a&#x27;,</span><br><span class="line">                            ...);</span><br><span class="line"> </span><br><span class="line">insertinto customers(cust_id, cust_contact, cust_email, cust_name, ...)</span><br><span class="line">select cust_id, cust_contact,...from custnew;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="20-更新和删除数据"><a href="#20-更新和删除数据" class="headerlink" title="20 更新和删除数据"></a>20 更新和删除数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#update语句由3部分组成：</span><br><span class="line">#要更新的表</span><br><span class="line">#列名和它们的新值：</span><br><span class="line">#确定要更新行的过滤条件。</span><br><span class="line">update customers set cust_email =&#x27;elmer@fudd.com&#x27;where cust_id =10005;</span><br><span class="line">update customers set cust_name =&#x27;the fudds&#x27;,</span><br><span class="line">    cust_email =&#x27;elmer@fudd.com&#x27;where cust_id =10005;</span><br><span class="line"></span><br><span class="line">update customers set cust_email =nullwhere cust_id =10005;</span><br><span class="line">deletefrom customers where cust_id =10006;</span><br><span class="line"># 如果省略where子句，它将删除表中每个客户</span><br><span class="line"># 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</span><br><span class="line">#在对update或delete语句where子句前，应该先用selete进行测试，保证它过滤的是正确的记录，以防编写where子句不正确。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="21-创建和操纵表"><a href="#21-创建和操纵表" class="headerlink" title="21 创建和操纵表"></a>21 创建和操纵表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">createtable customers</span><br><span class="line">(</span><br><span class="line">    cust_id         int         notnullauto_increment,</span><br><span class="line">    cust_name       char(50)    notnull,</span><br><span class="line">    cust_address    char(50)    null,</span><br><span class="line">    cust_city       char(50)    null,</span><br><span class="line">    ...</span><br><span class="line">)engine=innodb;</span><br><span class="line">#指定默认值</span><br><span class="line">createtable orderitems</span><br><span class="line">(</span><br><span class="line">    order_num   int     notnull,</span><br><span class="line">    order_item  int     notnull,</span><br><span class="line">    prod_id     char(10)    notnull,</span><br><span class="line">    quantity    int     notnulldefault1,# 未给出数量时，使用数量1.</span><br><span class="line">    item_price  decimal(8,2)    notnull,</span><br><span class="line">    primarykey(order_num, order_item)</span><br><span class="line">)engine=innodb;#引擎类型</span><br><span class="line">#innodb：一个可靠的事务处理引擎，不支持全文本搜索</span><br><span class="line">#memory:功能等同于myisam， 但由于数据存储在内存中，速度很快</span><br><span class="line">#myisam：一个性能极高的引擎，支持全文本搜索，但不支持事务处理</span><br><span class="line">altertable vendors add vend_phone char(20);#给表vendors增加一个名为vend_phone的列， 明确数据类型。</span><br><span class="line">altertable vendors dropcolumn vend_phone;#删除列</span><br><span class="line"></span><br><span class="line">#删除表 永久</span><br><span class="line">droptable customers2;</span><br><span class="line">#重命名</span><br><span class="line">renametable customers2 to customers;</span><br></pre></td></tr></table></figure><h1 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22 使用视图"></a>22 使用视图</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#视图是一个虚拟的表，帮助我们不必了解表的创建和表的联结，也可以查询我们想要的数据。</span><br><span class="line">#视图仅仅是用来查看存储在别处的数据的一种设施，视图本身不包含数据，因此他们返回的数据是从其他表中检索出来的。</span><br><span class="line">#在添加或更改这些表中的数据时，视图将返回改变过的数据。</span><br><span class="line">#利用视图简化复杂的联结</span><br><span class="line">createview productcustomers asselect cust_name, cust_contact, prod_id from customers, orders,</span><br><span class="line">orderitems where customers.cust_id= orders.cust_idand orderitems.order_num= orders.order_num;</span><br><span class="line"></span><br><span class="line">select cust_name, cust_contact from productcustomers where prod_id =&#x27;TNT2&#x27;;</span><br><span class="line">#视图极大地简化了复杂SQL语句的使用，利用视图，可一次性编写基础SQL，然后根据需要多次使用。</span><br><span class="line">#用视图重新格式化检索出的数据</span><br><span class="line">select concat(RTrim(vend_name),&#x27; (&#x27;, RTrim(vend_country),&#x27;)&#x27;)as vend_title from vendors orderby vend_name;</span><br><span class="line"></span><br><span class="line">createview vendorlocations asselect concat(RTrim(vend_name),&#x27; (&#x27;, RTrim(vend_country),&#x27;)&#x27;)</span><br><span class="line">as vend_title from vendors orderby vend_name;</span><br><span class="line">#过滤</span><br><span class="line">createview customeremaillist asselect cust_id. cust_name, cust_email from customers where cust_email isnotnull;</span><br><span class="line">#</span><br><span class="line">createview orderitemsexpanded asselect order_num, prod_id, quantity, item_price,</span><br><span class="line">            quantity*item_price as expanded_price from orderitems;</span><br><span class="line"></span><br><span class="line">select*from orderitemsexpanded where order_num =20005;</span><br><span class="line">#视图应该用于检索而不是更新。</span><br></pre></td></tr></table></figure><h1 id="23使用存储过程"><a href="#23使用存储过程" class="headerlink" title="23使用存储过程"></a>23使用存储过程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#执行存储过程</span><br><span class="line">call productpricing(@pricelow,</span><br><span class="line">                  @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br><span class="line">#创建存储过程                     </span><br><span class="line">createprocedure productpricing()</span><br><span class="line">begin</span><br><span class="line">    selectavg(prod_price)as priceaverage</span><br><span class="line">    from products;</span><br><span class="line">end;</span><br><span class="line">call productpricing();</span><br><span class="line">dropprocedure productpricing;</span><br><span class="line">#使用参数</span><br><span class="line">createprocedure productpricing(</span><br><span class="line">    out p1 decimal(8,1),</span><br><span class="line">    out ph decimal(8,2),</span><br><span class="line">    out pa decimal(8,2),</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">    selectmin(prod_price)</span><br><span class="line">    into p1</span><br><span class="line">    from product;</span><br><span class="line">    selectmax(prod_price)</span><br><span class="line">    into ph</span><br><span class="line">    from product;</span><br><span class="line">    selectavg(prod_price)</span><br><span class="line">    into pa</span><br><span class="line">    from product;</span><br><span class="line">end;</span><br><span class="line">##</span><br><span class="line">call productpricing(@pricelow,</span><br><span class="line">                   @pricehigh,</span><br><span class="line">                   @priceaverage);</span><br><span class="line"># 所有mysql变量都必须以@开始</span><br><span class="line">select@priceaverage;</span><br><span class="line">##</span><br><span class="line">select@pricehigh,@pricelow,@priceaverage;</span><br><span class="line">##</span><br><span class="line">createprocedure ordertotal(</span><br><span class="line">    in onumber int,        #传入存储过程</span><br><span class="line">    out ototal decimal(8,2) #传出存储过程</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">    selectsum(item_price*quantity)</span><br><span class="line">    from orderitems</span><br><span class="line">    where order_num = onumber</span><br><span class="line">    into ototal;</span><br><span class="line">end;</span><br><span class="line">##</span><br><span class="line">call ordertotal(20005,@total);</span><br><span class="line">select@total;</span><br><span class="line"># 检查存储过程</span><br><span class="line">showcreateprocedure ordertotal;</span><br></pre></td></tr></table></figure><h1 id="24-使用游标"><a href="#24-使用游标" class="headerlink" title="24 使用游标"></a>24 使用游标</h1><ul><li>游标是一个存存储在Mysql服务器上的数据库查询，他不是一条select语句，而是被语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">createprocedure processorders()</span><br><span class="line">begin</span><br><span class="line">    declare ordernumbers cursorforselect order_num from orders;</span><br><span class="line">end;</span><br><span class="line">#declare (声明)语句用来定义和命名游标</span><br><span class="line">open ordernumbers;</span><br><span class="line">close ordernumbers;</span><br><span class="line">##</span><br><span class="line">createprocedure processorders()</span><br><span class="line">begin</span><br><span class="line">    declare the cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    </span><br><span class="line">    open ordernumbers;</span><br><span class="line">    fetch ordernumbers into o;</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end;</span><br><span class="line">##</span><br><span class="line">createprocedure processorders()</span><br><span class="line">begin</span><br><span class="line">    declare done boolen default0;</span><br><span class="line">    declare o int;</span><br><span class="line">    declare t decimal(8,2);</span><br><span class="line">    declare ordernumbers cursorforselect order_num from orders;</span><br><span class="line">    declarecontinuehandlerforsqlstate&#x27;02000&#x27;set done =1;</span><br><span class="line">    </span><br><span class="line">    createtableifnotexists ordertotals (order_num int, total decimal(8,2));</span><br><span class="line">    </span><br><span class="line">    open ordernumbers;</span><br><span class="line">    </span><br><span class="line">    repeat</span><br><span class="line">        fetch ordernumbers into o;</span><br><span class="line">        </span><br><span class="line">        call ordertotal(o,1, t);</span><br><span class="line">        </span><br><span class="line">        -- insert order and total into ordertotals</span><br><span class="line">        insertinto ordertotals(order_num, total)values(o, t);</span><br><span class="line">        until done endrepeat;</span><br><span class="line">        close ordernumbers;</span><br><span class="line">end;</span><br><span class="line">##  </span><br></pre></td></tr></table></figure><p>​    </p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
