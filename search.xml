<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP报文</title>
      <link href="/2023/09/26/HTTP%E6%8A%A5%E6%96%87/"/>
      <url>/2023/09/26/HTTP%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>报文首部（C&#x2F;S通讯处理的重要信息）+ 空行 + 报文主体（资源信息）</p><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>报文首部（<strong>请求行</strong> + HTTP首部字段&lt;请求首部字段 + 通用首部字段 + 实体首部字段&gt; + 其他）</p><ul><li></li></ul><p>空行<br>+</p><p>报文主体</p><blockquote><p>请求行里：方法 、URI、HTTP版本</p></blockquote><h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p>报文首部（<strong>状态行</strong> + HTTP首部字段&lt;响应首部字段 + 通用首部字段 + 实体首部字段&gt; + 其他）</p><ul><li></li></ul><p>空行<br>+</p><p>报文主体</p><blockquote><p>状态行里：HTTP版本 、状态码（200 OK）</p></blockquote><h2 id="首部字段类型（4种）"><a href="#首部字段类型（4种）" class="headerlink" title="首部字段类型（4种）"></a>首部字段类型（4种）</h2><ol><li><p>通用首部字段 </p><ul><li>请求报文和响应报文都会用到的首部。</li></ul></li><li><p>请求首部字段</p><ul><li>补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li></ul></li><li><p>响应首部字段</p><ul><li>补充了响应时的附加内容，也会要求客户端附加额外的内容信息。</li></ul></li><li><p>实体首部字段</p><ul><li>补充了资源内容更新时间等与实体有关的信息。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之索引是个啥？</title>
      <link href="/2023/09/24/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/"/>
      <url>/2023/09/24/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之索引是个啥？"><a href="#MySQL之索引是个啥？" class="headerlink" title="MySQL之索引是个啥？"></a>MySQL之索引是个啥？</h1><h2 id="1-索引是啥？"><a href="#1-索引是啥？" class="headerlink" title="1. 索引是啥？"></a>1. 索引是啥？</h2><p>索引就是数据的目录，帮助存储引擎快速找到数据的一种<strong>数据结构</strong>。</p><h2 id="2-索引存在哪？"><a href="#2-索引存在哪？" class="headerlink" title="2. 索引存在哪？"></a>2. 索引存在哪？</h2><p>索引和数据都存在存储引擎里。（物理上在硬盘里）</p><p><img src="/../MySQL/2.png" alt="2"></p><h2 id="3-索引的分类"><a href="#3-索引的分类" class="headerlink" title="3. 索引的分类"></a>3. 索引的分类</h2><p><img src="/../MySQL/3.png" alt="3"></p><p>在InnoDB引擎里，索引使用B+树的数据结构。</p><h2 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4. B+ 树"></a>4. B+ 树</h2><p>B+ 树 是 <strong>多叉树</strong> ， 叶子节点放数据，<strong>非叶子节点只放索引</strong>。在叶子节点里有所有的索引值信息，而且每个叶子节点有两个指针，构成双向链表。</p><p><img src="/../MySQL/4.png" alt="image-20230924214103011"></p><p>B+树存储千万级数据只需要3-4层就够了。</p><p><strong>优势</strong>：查询效率高。<strong>因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p><h2 id="5-为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#5-为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="5. 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>5. 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h2><p>B+树只在叶子节点存数据，但是B树非叶子节点也存数据，B+树单个节点数据量小，树的高度低，IO次数少。</p><p>B+树叶子节点用双向链表连接，适合MySQL常见基于范围的顺序查找，而 B 树无法做到这一点。B+树查询复杂度$O(log_2{dN})$  d表示节点允许的最大子节点个数为 d 个。</p><h2 id="6-主键索引、唯一索引、普通索引、前缀索引-按字段特性分"><a href="#6-主键索引、唯一索引、普通索引、前缀索引-按字段特性分" class="headerlink" title="6. 主键索引、唯一索引、普通索引、前缀索引 (按字段特性分)"></a>6. 主键索引、唯一索引、普通索引、前缀索引 (按字段特性分)</h2><ol><li>主键索引的B+树的叶子节点存放实际数据，普通索引或者二级索引放主键的值。</li></ol><p>主键索引：一张表只能有一个，索引列的值不能为空值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (</span><br><span class="line">    ...</span><br><span class="line">    PRIMARY KEY (index_column_1) USING BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>唯一索引：建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p></li><li><p>普通索引：允许有空值，可以有多个。建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p></li><li><p>前缀索引： 前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p><strong>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</strong></p></li></ol><h2 id="7-索引啥时候用合适啊？"><a href="#7-索引啥时候用合适啊？" class="headerlink" title="7. 索引啥时候用合适啊？"></a>7. 索引啥时候用合适啊？</h2><p>索引的好处是提高查询速度，<strong>但是缺点：</strong></p><ol><li>需要占用空间</li><li>创建维护索引耗费时间，数据越多越耗时。</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ol><p><strong>适用场景：</strong></p><ol><li>字段唯一 ，如学号，商品编号。</li><li>经常用<code>where</code>查询条件的字段，可以提高查询速度，不是一个字段，可以用联合索引。</li><li>经常用<code>order by</code>和<code>group by</code> ， 建立索引后B+树中的记录是排好序的，就不用在排序一次了。</li></ol><p><strong>不适用场景：</strong></p><ol><li>索引用来快速定位，起不到定位作用的字段不用建立索引，浪费空间。</li><li>字段里有大量重复数据，比如： 男 ， 女</li><li>表里数据太少</li><li>经常更新的字段不用建立索引。因为索引字段频繁修改，<strong>由于要维护 B+Tree的有序性</strong>，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ol><h2 id="8-索引优化的方法有啥？"><a href="#8-索引优化的方法有啥？" class="headerlink" title="8. 索引优化的方法有啥？"></a>8. 索引优化的方法有啥？</h2><ul><li>前缀索引优化<ul><li>使用字段中字符串的前几个字符建立索引，可以减小索引字段大小，提高在索引页里查索引的速度。</li></ul></li><li>覆盖索引优化<ul><li>二级索引里中能查询得到记录，不需要通过聚簇索引查询获得，避免了回表。</li></ul></li><li>主键索引最好是自增的。</li><li>索引最好设置为NOT NULL。<ul><li>原因1：索引列有NULL会导致优化器难做索引选择，更复杂。</li><li>原因2：NULL没意义，占空间。</li></ul></li><li>防止索引失效。<ul><li>我们有时候会写出一些查询语句导致索引失效。</li><li>失效情况：<ul><li>用了左右模糊匹配， <code>like %xx</code>  或者<code>like %xx%</code></li><li>对索引列使用了计算，函数，类型转换。（MySQL8.0后，增加了函数索引，可以针对函数计算后的值再建立一个索引）。</li><li>使用联合索引时没有遵守最左匹配原则。</li><li>where子句中的OR。如果在OR前的条件列是索引列，而在OR后的条件列不是索引列，那么索引会失效。</li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../MySQL/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.webp"></p><p>（图片来自：小林coding）</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之执行select语句的流程</title>
      <link href="/2023/09/24/MySQL%E4%B9%8B%E6%89%A7%E8%A1%8Cselect%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/09/24/MySQL%E4%B9%8B%E6%89%A7%E8%A1%8Cselect%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之"><a href="#MySQL之" class="headerlink" title="MySQL之"></a>MySQL之</h1><h1 id="1-执行select语句的流程"><a href="#1-执行select语句的流程" class="headerlink" title="1.执行select语句的流程"></a>1.执行select语句的流程</h1><p><img src="/../MySQL/1.png" alt="image-20230924205616732"></p><ul><li>第一步连接MySQL服务，先经过TCP三次握手，MySQL基于TCP传输数据。推荐使用长连接（但存在内存占用问题）。</li><li>第二步查询缓存。但对于更新频繁的表，查询缓存的命中率低，所以8.0后<strong>查询缓冲</strong>删掉了，删去了server层缓存。</li><li>第三步如果缓存没命中，<strong>解析器</strong>开始解析SQL语句：词法分析、语法分析。</li><li>第四步：执行SQL。三个阶段：预处理、优化阶段（确定SQL查询语句的执行方案，如选择哪个索引）、执行阶段。8.0版本判断表或字段存在不存在是在预处理阶段执行的。</li></ul><blockquote><p>索引：用来快速查找数据的数据结构，InnoDB中默认使用B+树。索引类型：主键索引（聚簇索引）和二级索引（非主键索引）。</p><p>回表：在查询流程中，需要从非主键索引树搜索回到主键索引树搜索的过程叫回表。</p><p>覆盖索引（索引覆盖）：从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。这是一种数据库的性能优化手段。</p><p>如何使用覆盖索引：修改非主键索引为联合索引，在一颗搜索树上就能得到想要的数据，不用再去主键搜索树上查了。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/2023/09/21/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/09/21/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的线程同步"><a href="#C语言中的线程同步" class="headerlink" title="C语言中的线程同步"></a>C语言中的线程同步</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>当一个线程对内存中的共享资源进行访问的时候，其他线程都不可以操作这块内存，直到线程 A 对这块内存访问完毕为止。</p><h2 id="2-为什么要实现线程同步"><a href="#2-为什么要实现线程同步" class="headerlink" title="2 为什么要实现线程同步"></a>2 为什么要实现线程同步</h2><p>为了使多个线程操作同一个全局变量的时候，全局变量的数据被及时正确的读取、计算、写入内存中，保证程序正确的执行下去。</p><h2 id="3-同步方式"><a href="#3-同步方式" class="headerlink" title="3 同步方式"></a>3 同步方式</h2><ul><li>互斥锁 </li><li>读写锁</li><li>条件变量</li><li>信号量</li></ul><blockquote><p>所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为临界资源。</p></blockquote><p><img src="/../%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/image-20200106092600543.png" alt="image-20200106092600543"></p><ul><li>临界区上边上锁，下边解锁</li></ul><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1. 互斥锁"></a>1. 互斥锁</h3><ul><li><p>通过互斥锁可以锁定一个代码块，</p></li><li><p>被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要<strong>付出的代价就是执行效率的降低</strong>，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p></li><li><p>创建一把互斥锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数:</span></span><br><span class="line"><span class="comment">//mutex: 互斥锁变量的地址</span></span><br><span class="line"><span class="comment">//attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</span></span><br></pre></td></tr></table></figure></li><li><p>上锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure></li><li><p>尝试加锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(pthread_mutex* mutex)</span>;</span><br><span class="line"><span class="comment">//如果锁变量是锁定的，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号。</span></span><br></pre></td></tr></table></figure></li><li><p>解锁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(pthread_mutex* mutex)</span>;</span><br><span class="line"><span class="comment">//不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>死锁</strong>：锁使用不当，如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有：</p><ul><li><p>加锁后忘记解锁</p></li><li><p>重复加锁，造成死锁</p></li><li><p>程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">场景描述:</span><br><span class="line">  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B</span><br><span class="line">     - 线程A访问资源X, 加锁A</span><br><span class="line">     - 线程B访问资源Y, 加锁B</span><br><span class="line">  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞</span><br><span class="line">     - 线程A被锁B阻塞了, 无法打开A锁</span><br><span class="line">     - 线程B被锁A阻塞了, 无法打开B锁</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="2-读写锁-–-是互斥锁的升级版"><a href="#2-读写锁-–-是互斥锁的升级版" class="headerlink" title="2. 读写锁  – (是互斥锁的升级版)"></a>2. 读写锁  – (是互斥锁的升级版)</h3><ul><li><p>创建 ：<code>pthread_rwlock_t rwlock;</code> </p></li><li><p>在<strong>做读操作的时候可以提高程序的执行效率</strong>，如果所有的线程都是做读操作, 那么读是并行的</p></li><li><p>如果读写锁锁定了读操作，需要先解锁才能锁定写操作，反之亦然。</p></li><li><p>读写锁的特点：</p><ol><li>读锁是共享的</li><li>写锁是独占的</li><li>写锁比读锁的优先级高。</li></ol></li></ul><blockquote><p>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源<strong>读的操作越多，读写锁更有优势</strong>。</p></blockquote><ul><li><ul><li>读写锁是一把锁， 锁定了读操作，就不能锁定写操作了，不能同时锁定。</li></ul></li><li>读写锁的操作函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">//初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">//attr: 读写锁属性，一般使用默认属性，指定为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlocck)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlocck)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h3><p><strong>条件变量的主要作用不是处理线程同步，而是进行线程的阻塞</strong>。<strong>在多线程程序中，条件变量需要配合互斥锁来使用。</strong></p><p>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</p><p><strong>分工</strong>：互斥锁用来做线程同步；条件变量用来阻塞线程的。</p><ul><li>条件变量的操作函数如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* <span class="keyword">restrict</span> attr)</span>;<span class="comment">//att 指定为NULL</span></span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><h4 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h4><p><img src="/../%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/1564644834918.png" alt="1564644834918"></p><p>生产者和消费者模型的组成：</p><ol><li>生产者线程 -&gt; 若干个<ol><li>生产商品或者任务放入到任务队列中</li><li>任务队列满了就阻塞，不满的时候就工作</li><li>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</li></ol></li><li>消费者线程 -&gt; 若干个<ol><li>读任务队列，将任务或者数据取出</li><li>任务队列中有数据就消费，没有数据就阻塞</li><li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li></ol></li><li>队列-&gt;存储任务 &#x2F; 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存<ul><li>可以是数组、链表，也可以使用 <code>stl</code>容器：<code>queue / stack / list / vector</code></li></ul></li></ol><h3 id="4-信号量–-用起来比条件变量简单"><a href="#4-信号量–-用起来比条件变量简单" class="headerlink" title="4. 信号量–  用起来比条件变量简单"></a>4. 信号量–  用起来比条件变量简单</h3><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。<strong>信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</strong></p><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为 <code>&lt;semaphore.h&gt;：</code></p><p>信号量操作函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建信号量</span></span><br><span class="line"><span class="type">sem_t</span> sem1;</span><br><span class="line"><span class="type">sem_t</span> sem2;</span><br><span class="line"><span class="comment">//初始化信号量/灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数       </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数:<br><code>sem</code>：信号量变量地址<br><code>pshared</code>：<br>0：线程同步<br>非 0：进程同步<br>value：初始化当前信号量拥有的资源数（&gt;&#x3D;0），如果资源数为 0，线程就会被阻塞了.</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">// sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号</span></span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line"><span class="comment">//查看信号量sem中的整型数的当前值，个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span>* sval)</span>;</span><br></pre></td></tr></table></figure><h4 id="总资源数为1"><a href="#总资源数为1" class="headerlink" title="总资源数为1"></a>总资源数为1</h4><p>如果生产者和消费者使用的信号量总资源数为 1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p><h4 id="总资源数大于-1"><a href="#总资源数大于-1" class="headerlink" title="总资源数大于 1"></a><strong>总资源数大于 1</strong></h4><p><strong>为防止共享资源出现数据混乱，需要使用互斥锁进行线程同步。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//作者: 苏丙榅</span></span><br><span class="line"><span class="comment">//链接: https://subingwen.cn/linux/thread-sync/</span></span><br><span class="line"><span class="comment">//来源: 爱编程的大丙</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-C语言</title>
      <link href="/2023/09/21/%E7%BA%BF%E7%A8%8B-C%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/09/21/%E7%BA%BF%E7%A8%8B-C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的线程"><a href="#C语言中的线程" class="headerlink" title="C语言中的线程"></a>C语言中的线程</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><ol><li><p>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p></li><li><p>进程和线程的区别：</p><ul><li><p>进程有自己独立的地址空间，多个线程共用同一个地址空间。</p><ul><li><p>在一个地址空间中，多个线程独享：栈区，寄存器。</p></li><li><p>在一个地址空间中，多个线程共享：代码区，堆区，全局数据区，打开的文件。</p></li></ul></li><li><p>线程是程序的最小执行单元，进程是最小的资源分配单位。</p></li><li><p>CPU的调度和切换：线程的上下文切换比进程要快的多。</p></li><li><p>线程更加廉价，启动速度快，退出快，对系统资源的冲击小。</p></li></ul></li></ol><h2 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">phread_t</span> <span class="title">phread_self</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//线程函数，返回当前线程的ID</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</span></span><br></pre></td></tr></table></figure><ul><li>虚拟地址空间的生命周期和主线程是一样的，与子线程无关。</li><li>sleep（）：可以让主线程挂起，让子线程执行完毕，主线程再退出。</li></ul><h2 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">phtread_eixt</span><span class="params">(<span class="type">void</span> *retval)</span></span>;<span class="comment">//只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。</span></span><br><span class="line"><span class="comment">//主线程调用退出函数退出, 地址空间不会被释放</span></span><br></pre></td></tr></table></figure><h2 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h2><blockquote><p>子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做<code> pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p></blockquote><h3 id="4-1-回收子线程数据"><a href="#4-1-回收子线程数据" class="headerlink" title="4.1 回收子线程数据"></a>4.1 回收子线程数据</h3><ul><li><p>使用子线程栈 ：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_exit</span>(&amp;p); <span class="comment">//子线程退出</span></span><br><span class="line"><span class="built_in">pthread_join</span>(tid, &amp;ptr); <span class="comment">//主线程回收子线程资源，通过ptr void*类型指针传出子线程数据。</span></span><br></pre></td></tr></table></figure></li><li><p>使用全局变量</p><ul><li>位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是<strong>可以共享全局数据区和堆区数据</strong>，因此在子线程退出的时候可以将<strong>传出数据存储到全局变量、静态变量或者堆内存</strong>中。</li></ul></li><li><p>使用主线程栈</p></li></ul><h2 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 <code>pthread_join()</code> 就回收不到子线程资源了。</p></li><li><p>为何使用线程分离：因为主线程有自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code> pthread_join()</code> 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p></li></ul><h2 id="6-其他线程函数"><a href="#6-其他线程函数" class="headerlink" title="6. 其他线程函数"></a>6. 其他线程函数</h2><ul><li><p>线程取消</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span>, thread)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用这个函数杀死一个线程需要分两步：</p><p>在线程 A 中调用线程取消函数 <code>pthread_cancel</code>，指定杀死线程 B，这时候线程 B 是死不了的<br>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。</p></blockquote></li><li><p>线程ID比较</p><ul><li><p>在 Linux 中线程 ID 本质就是一个无符号长整形，在某些平台上<code>pthread_t</code>可能不是一个单纯的整形，这种情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数：t1 和 t2 是要比较的线程的线程 ID<br>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</p></blockquote></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式云盘</title>
      <link href="/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E7%9B%98/"/>
      <url>/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/../%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%9B%98/1.png" alt="1"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
