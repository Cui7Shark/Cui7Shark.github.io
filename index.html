<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-网盘项目笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E7%BD%91%E7%9B%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:42:38.000Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/20/%E7%BD%91%E7%9B%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/">网盘项目笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="cloud-disk"><a href="#cloud-disk" class="headerlink" title="cloud_disk"></a>cloud_disk</h1><blockquote>
<p>云盘项目: <a target="_blank" rel="noopener" href="https://github.com/Cui7Shark/cloud_disk">https://github.com/Cui7Shark/cloud_disk</a></p>
</blockquote>
<h2 id="1-项目总体架构"><a href="#1-项目总体架构" class="headerlink" title="1. 项目总体架构"></a>1. 项目总体架构</h2><p>首先搭建fastdfs分布式文件服务器集群，再利用ngnix反向代理服务器，接收并处理用户的请求，其中还使用了FastCGI+spawn-fcgi配合nginx工作；<br>然后还用到了MySQL和Redis数据库，其中MySQL用于存储文件的信息，Redis呢主要用于存储用户注册登录之类的鉴权信息。</p>
        
          <p class="article-more-link">
            <a href="/2023/09/20/%E7%BD%91%E7%9B%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E7%BD%91%E7%9B%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" data-id="clmruvmef00009ctj508m6waq" data-title="网盘项目笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-链接动态库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.047Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gcc echo.c -o app</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找不到库</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜库</span></span><br><span class="line">find ./ -name &quot;lib*&quot;</span><br><span class="line"></span><br><span class="line">gcc echo.c -o app -lfcgi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成app</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动之前先</span></span><br><span class="line">ldd app</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看app 能不能链接到库</span></span><br><span class="line">[root@10-41-93-228 home]# ldd app</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffd6a396000)</span><br><span class="line">	libfcgi.so.0 =&gt; not found</span><br><span class="line">	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f94ea1b1000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f94ea57f000)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找库</span></span><br><span class="line">find / -name &quot;libfcgi.so&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果</span></span><br><span class="line">/usr/local/lib/libfcgi.so</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把路径添加到库配置文件中</span></span><br><span class="line">vim /etc/ld.so.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进去后，自动就把路径添加上了 oVo</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后</span></span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再次</span></span><br><span class="line">ldd app</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">成功了</span></span><br><span class="line">[root@10-41-93-228 home]# ldd app</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffdeebc4000)</span><br><span class="line">	libfcgi.so.0 =&gt; /usr/local/lib/libfcgi.so.0 (0x00007f9124da6000)</span><br><span class="line">	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f91249d8000)</span><br><span class="line">	libnsl.so.1 =&gt; /lib64/libnsl.so.1 (0x00007f91247be000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f9124fb1000)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结束！</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93/" data-id="clmrundc3000dwstjdytkakdq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.043Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>《计算机网络：自定向下方法》中科大课程</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/25757674/1676620952569-641f09ff-183e-4f61-86bd-034756092db3.pdf">📎计算机网络-郑老师-第1章.pdf</a><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/25757674/1676620952526-7c013feb-01ea-4abe-a6de-fab389da50df.pdf">📎计算机网络-郑老师-第2章.pdf</a><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/25757674/1676620952515-140f0360-7da0-42c2-92e2-b70707bfc87f.pdf">📎计算机网络-郑老师-第3章.pdf</a><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/25757674/1676620952516-fbcead49-1165-41af-8ede-9685b69fcf53.pdf">📎计算机网络-郑老师-第4章.pdf</a><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/25757674/1676620952519-fd7ccd6e-8c7c-4f95-a186-448993675a15.pdf">📎计算机网络-郑老师-第5章.pdf</a><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/25757674/1676620952856-41bf7766-dd86-4cbf-8631-f26d66b6ef2d.pdf">📎计算机网络-郑老师-第6章.pdf</a><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/25757674/1676620952903-6aed1701-1749-49a8-8b97-f9c6bc967e43.pdf">📎计算机网络-郑老师-第8章.pdf</a></p>
<h1 id="第1章-计算机网络和因特网"><a href="#第1章-计算机网络和因特网" class="headerlink" title="第1章 计算机网络和因特网"></a>第1章 计算机网络和因特网</h1><h2 id="1-1什么是因特网"><a href="#1-1什么是因特网" class="headerlink" title="1.1什么是因特网"></a>1.1什么是因特网</h2><ol>
<li>协议：定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送&#x2F;或接受一条报文或其他事件所采取的动作。</li>
</ol>
<h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2.网络边缘"></a>1.2.网络边缘</h2><ol>
<li>光纤分布体系结构：主动光纤网络（AON）；被动光纤网络（PON）</li>
</ol>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3.网络核心"></a>1.3.网络核心</h2><ul>
<li>分组交换的性能够优于电路交换的性能。</li>
<li>网络的网络:</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1673847645711-85e246fb-f118-4345-8d34-645d0583be4f.png" alt="img"></p>
<h2 id="1-4传输时延和传播时延、丢包和吞吐量"><a href="#1-4传输时延和传播时延、丢包和吞吐量" class="headerlink" title="1.4传输时延和传播时延、丢包和吞吐量"></a>1.4传输时延和传播时延、丢包和吞吐量</h2><ul>
<li>传输时延是路由器推出分组所需要的时间,它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。</li>
<li>传播时延是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间距离的函数，而与分组长度或链路传输速率无关。</li>
<li>吞吐量取决于数据流过的链路的传输速率，而且取决于干扰流量。</li>
<li>因特尔的协议栈五个层次：物理层、链路层、网络层、运输层和应用层。</li>
<li>报文（message）：应用层的协议分布在多个端系统上，一个端系统1中应用程序使用协议与另一个端系统中的应用程序交换信息分组。这种位于应用层的信息分组称为报文。</li>
<li>运输层：在应用程序端点之间传送应用层报文。有两种运输协议，即TCP和UDP。</li>
<li>报文段（segment）:运输层的分组。</li>
<li>TCP：将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时，源印制其传输速率。</li>
<li>UDP:向它的应用程序提供无连接服务，不提供不必要服务，没有可靠性，没有流量控制，也没有拥塞控制。</li>
<li>瞬时吞吐量：主机B接受到该文件的速率（bps）</li>
</ul>
<h2 id="1-6-面对攻击的网络"><a href="#1-6-面对攻击的网络" class="headerlink" title="1.6.面对攻击的网络"></a>1.6.面对攻击的网络</h2><ul>
<li><p>Dos：拒绝服务攻击</p>
</li>
<li><p>Dos攻击三种类型：	</p>
</li>
<li><ul>
<li>\1. 弱点攻击	</li>
<li>\2. 带宽洪泛</li>
<li>\3. 连接洪泛</li>
</ul>
</li>
</ul>
<p>分布式Dos，攻击者控制多个源并让每个源向目标猛烈发送流量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>用来观察执行协议实体之间交换的报文的基本工具成为分组嗅探器。它可以显示出这些被捕报文的各个协议字段的内</li>
</ul>
<p>容。</p>
<ul>
<li>计算机网络分层的必要性</li>
<li><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677307235035-cf4bcb68-b931-43a9-9b7a-0d3070fb45fa.png" alt="img"></li>
</ul>
<h1 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h1><h2 id="2-1应用层协议原理"><a href="#2-1应用层协议原理" class="headerlink" title="2.1应用层协议原理"></a>2.1应用层协议原理</h2><h3 id="1-网络应用程序体系结构"><a href="#1-网络应用程序体系结构" class="headerlink" title="1 网络应用程序体系结构"></a>1 网络应用程序体系结构</h3><ul>
<li>传输层向应用层提供服务</li>
</ul>
<ol>
<li><p>应用程序体系结构：由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。</p>
</li>
<li><ol>
<li>客户-服务器体系结构</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li><ul>
<li>服务器服务于来自许多其他称为客户的主机的请求。例如Web应用程序，当Web服务器接收到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。(80端口)</li>
<li>缺陷：可拓展性较差，可靠性差</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><ol>
<li>P2P体系结构</li>
</ol>
</li>
</ol>
<ul>
<li><ul>
<li><ul>
<li>对位于数据中心的专用服务器有最小的依赖，相反，应用程序在间断连接的主机对之间使用直接通信，这些主机称为对等方。如，文件共享（BitTorrent）, 因特网电话和视频会议。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1673882792394-d101ff88-74be-450c-ac05-dcacfb2cf228.png" alt="img"></p>
<h3 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2 进程通信"></a>2 进程通信</h3><ul>
<li><p>进程（process）</p>
</li>
<li><ul>
<li><ul>
<li>一个进程可以被认为是运行在端系统中的一个程序。</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP上的socket（套接字）:代表本地和对方的ip和端口的标识，只作用于本地；只有应用层和传输层知道，一种约定。是四元组的一个具有本地意义的标识。</p>
</li>
<li><p>四元组：源ip，源port，目标ip，目标port ;</p>
</li>
<li><p>UDP上的socket：二元组的一个具有本地意义的标识， 二元组：本地ip和本地端口。</p>
</li>
</ul>
<ol>
<li>客户和服务器进程</li>
</ol>
<ul>
<li>在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其它进程的联系）的进程被标识为客户，在会话开始时等待联系的进程是服务器。</li>
</ul>
<ol>
<li>进程与计算机网络之间的接口</li>
</ol>
<ul>
<li>进程通过一个称为套接字的软件接口向网络发送报文和从网络接受报文。</li>
<li>套接字是同一台主机内应用层与运输层之间的接口。称为应用程序和网络之间的应用程序编程接口（API）</li>
</ul>
<ol>
<li>进程寻址</li>
</ol>
<ul>
<li>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接受进程需要有一个地址。为了标识接受进程，需要定义两种信息：1.主机的地址；2.在目的主机中指定接受进程的标识符。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1673884534685-96ba5261-e3be-4203-8556-374a91418662.png" alt="img"></p>
<h3 id="3-因特网提供的运输服务"><a href="#3-因特网提供的运输服务" class="headerlink" title="3 因特网提供的运输服务"></a>3 因特网提供的运输服务</h3><ol>
<li>TCP服务</li>
</ol>
<ul>
<li>面向连接服务和可靠数据传输服务</li>
<li>具有拥塞控制机制</li>
</ul>
<ol>
<li>UDP服务</li>
</ol>
<ul>
<li>不提供不必要的轻量级运输协议，仅提供最小服务，是无连接的，在两个进程通信前没有握手过程；提供一种不可靠数据传送服务。</li>
</ul>
<ol>
<li>因特网运输协议所不提供的服务</li>
</ol>
<ul>
<li>没有提供吞吐量和定时服务</li>
</ul>
<h3 id="4-应用层协议"><a href="#4-应用层协议" class="headerlink" title="4 应用层协议"></a>4 应用层协议</h3><ul>
<li><p>把报文发送进套接字实现网络进程间的相互通信。</p>
</li>
<li><p>应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文</p>
</li>
<li><ul>
<li><ul>
<li>定义了：交换的报文类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-HTTP概况"><a href="#5-HTTP概况" class="headerlink" title="5 HTTP概况"></a>5 HTTP概况</h3><ul>
<li>HTTP：超文本传输协议，是Web的核心</li>
<li>HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</li>
<li>HTTP使用TCP作为它的支撑运输协议，客户端的套接字接口是客户进程与TCP连接之间的门，在服务器端的套接字接口则是服务器进程与TCP连接之间的门。</li>
<li>HTTP是一个<strong>无状态协议</strong>，不保存关于客户的任何信息。</li>
</ul>
<h2 id="2-2-Web和HTTP（超文本传输协议）"><a href="#2-2-Web和HTTP（超文本传输协议）" class="headerlink" title="2.2 Web和HTTP（超文本传输协议）"></a>2.2 Web和HTTP（超文本传输协议）</h2><h3 id="2-2-2-非持续连接和持续连接"><a href="#2-2-2-非持续连接和持续连接" class="headerlink" title="2.2.2 非持续连接和持续连接"></a>2.2.2 非持续连接和持续连接</h3><h4 id="1-采用非持续连接的HTTP"><a href="#1-采用非持续连接的HTTP" class="headerlink" title="1. 采用非持续连接的HTTP"></a>1. 采用非持续连接的HTTP</h4><ul>
<li>每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。</li>
<li>每个TCP连接只传输一个请求报文和一个响应报文。</li>
</ul>
<ol>
<li>往返时间（RTT）</li>
</ol>
<ul>
<li>该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间。</li>
<li>包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1674053328393-25ef3b52-db1e-41fe-920d-23691fbf6228.png" alt="img"></p>
<ol>
<li>三次握手</li>
</ol>
<ul>
<li>客户向服务器发送一个小的TCP报文段，服务器用一个小TCP报文段做出确认和响应；（一次握手）</li>
<li>客户向服务器返回确认；（二次握手）</li>
<li>完成三次握手的前两个部分后，客户结合三次握手的第三部分（确认）向该TCP连接发送一个HTTP请求报文。</li>
<li>该请求报文到达服务器后，服务器就在该TCP连接上发送（Web应用如HTML）文件</li>
<li>总的响应时间就是两个RTT加上服务器传输HTML文件的时间。</li>
</ul>
<ol>
<li>缺点</li>
</ol>
<ul>
<li>Web服务器负担大，客户和服务器都要分配TCP的缓冲区和保持TCP变量。</li>
<li>时间长；每个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接受一个对象。</li>
</ul>
<h4 id="2-采用持续连接的HTTP"><a href="#2-采用持续连接的HTTP" class="headerlink" title="2.采用持续连接的HTTP"></a>2.采用持续连接的HTTP</h4><ul>
<li>在采用HTTP1.1持续连接的情况下，服务器在发送响应后保持该TCP连接打开，在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。一个完整的Web页面可以用单个持续TCP连接进行传送。</li>
</ul>
<h3 id="2-2-3HTTP报文格式"><a href="#2-2-3HTTP报文格式" class="headerlink" title="2.2.3HTTP报文格式"></a>2.2.3HTTP报文格式</h3><ol>
<li>HTTP响应报文</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675233721825-589f90b4-bb13-4fea-9497-103a1a00308b.png" alt="img"></p>
<ul>
<li>HTTP请求报文第一行叫请求行，后继的行叫首部行，请求行三个字段：方法字段、URL字段和HTTP版本字段。绝大部分HTTP请求报文使用GET方法。</li>
</ul>
<ol>
<li>HTTP响应报文</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675235171070-09bfe1b2-2b91-4ac3-a018-7ccac2fe155f.png" alt="img"></p>
<ul>
<li>三个部分：初始状态行，6个首部行，实体体（entity body）</li>
<li>状态行3个字段：协议版本字段、状态码、相应状态信息</li>
<li>状态码及其相应短语指示了请求的结果</li>
</ul>
<p>常见的：<img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675235594282-2830f87a-d2cd-4d12-8cb9-a683279d6cb8.png" alt="img"></p>
<h2 id="2-3-因特网中的电子邮件"><a href="#2-3-因特网中的电子邮件" class="headerlink" title="2.3 因特网中的电子邮件"></a>2.3 因特网中的电子邮件</h2><p>电子邮件系统的三个主要组成部分：用户代理，邮件服务器，简单邮件传输协议（SMTP）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675262934755-16888ef0-1543-4263-8243-4ad0780f01dc.png" alt="img"></p>
<p>SMTP限制所有邮件报文的体部分只能采用简单的7比特ASCII表示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675263655376-d6d3aa5f-0791-4fe0-b5e5-80370f83f42a.png" alt="img"></p>
<h2 id="2-4-DNS：因特网的目录服务"><a href="#2-4-DNS：因特网的目录服务" class="headerlink" title="2.4 DNS：因特网的目录服务"></a>2.4 DNS：因特网的目录服务</h2><p>我们需要一种能进行主机名到IP地址转换的目录服务，这就是域名系统的主要任务。</p>
<p>DNS（Domain Name System,域名系统）是：一个有分层的DNS服务器实现的分布式数据库；一个使得主机能够查询分布式数据库的应用层协议。DNS服务器通常是运行BIND软件的UNIX机器。DNS协议运行在UDP之上，使用53号端口。</p>
<ul>
<li>DNS通过采用了位于网络边缘的客户和服务器，实现了关键的名字到地址转换功能。</li>
<li>DNS还提供了一些重要的服务：主机别名；邮件服务器别名；负载分配。</li>
</ul>
<p>DNS是一个分布式数据库：</p>
<ol>
<li>分布式、层次数据库</li>
</ol>
<p>根DNS服务器、顶级域DNS服务器和权威DNS服务器。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675346249409-30ddfa9f-256a-4088-8f44-13d1741bf50b.png" alt="img"></p>
<ul>
<li>从理论上讲，任何DNS查询既可以是迭代的也能是递归的。实践中，查询通常遵循：从请求主机到本地DNS服务器的查询是递归的，其余的查询时迭代的。</li>
</ul>
<ol>
<li>DNS缓存</li>
</ol>
<p>DNS缓存为了改善时延性能并减少在因特网上到处传输的DNS报文数量。在一个请求链中，当某DNS服务器接受一个DNS回答时，它能将映射缓存在本地存储器中，如果在DNS服务器中缓存了一台主机名&#x2F;IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该服务器就能够提供所要求的IP地址。</p>
<h2 id="2-5-P2P（略"><a href="#2-5-P2P（略" class="headerlink" title="2.5 P2P（略)"></a>2.5 P2P（略)</h2><h2 id="2-6-视频流和内容分发网"><a href="#2-6-视频流和内容分发网" class="headerlink" title="2.6 视频流和内容分发网"></a>2.6 视频流和内容分发网</h2><ul>
<li><p>在HTTP流中，视频只是存储在HTTP服务器中作为一个普通的文件，每个文件有一个特定的URL。</p>
</li>
<li><p>为适应不同客户的带框大小，研发了经HTTP的动态适应性流（DASH)。</p>
</li>
<li><p>CDN-内容分发网</p>
</li>
<li><ul>
<li>CDN的两种不同的服务器安置原则：</li>
</ul>
</li>
</ul>
<p>1.深入</p>
<p>2.邀请做客</p>
<ul>
<li><p>CDN操作</p>
</li>
<li><ul>
<li>当用户主机中的一个浏览器指令检索一个特定的视频（由URL标识）时，CDN必须截获该请求，以便能够：1.确定此时适合用于该客户的CDN服务器集群；2.将客户的请求重定向到该集群的某台服务器。</li>
<li>大多数CDN利用DNS来截获和重定向请求；</li>
</ul>
</li>
</ul>
<h2 id="2-7-TCP-UDP套接字编程-生成网络应用（重要）"><a href="#2-7-TCP-UDP套接字编程-生成网络应用（重要）" class="headerlink" title="2.7 TCP UDP套接字编程-生成网络应用（重要）"></a>2.7 TCP UDP套接字编程-生成网络应用（重要）</h2><ol>
<li>典型的网络应用是由一对程序（即客户程序和服务器程序）组成的，它们位于两个不同的端系统中，当运行这两个程序时，创建了一个客户进程和一个服务器进程，同时它们通过从套接字读出和写入数据在彼此之间进行通信。</li>
</ol>
<ul>
<li><p>网络应用程序有两类：</p>
</li>
<li><ul>
<li>\1. 由协议标准（如RFC）中所定义的操作的实现。独立的程序员开发的客户和服务器程序间可以通信。</li>
<li>2.专用的网络应用程序。开发者用他的代码完全控制该代码的功能。但是因为这些代码并没有实现一个开放的协议，其他独立的开发者将不能开发出和该应用程序交互的代码。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675414732298-2ac1314f-16a9-4f44-8dda-274ca9b1d8be.png" alt="img"></p>
<h3 id="2-UDP套接字编程"><a href="#2-UDP套接字编程" class="headerlink" title="2. UDP套接字编程"></a>2. UDP套接字编程</h3><ul>
<li>当使用UDP时，必须先将目的地址附在分组之上，在该分组传过发送方的套接字之后，因特网将使用该目的地址通过因特网为该分组选路到接收进程的套接字。当分组到达接收套接字时，接收进程将通过该套接字取回分组，然后检查分组的内容并采取适当的动作。每一个进程具有一个或多个套接字，所以在目的主机指定特定的套接字也是必要的。当生成一个套接字时，就为它分配一个称为端口号的标识符。该目的地址是由目的主机IP地址和目的地套接字的端口号组成。发送方的源地址也是由源主机的IP地址和源套接字的端口号组成，该源地址也要附在分组之上。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675473259837-32b87d6f-f968-4d38-af2c-c1dc89666acf.png" alt="img"></p>
<ul>
<li>1.UDPClient.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * 	<span class="comment">#形成在Python中所有网络通信的基础，我们能够在程序中创建套接字</span></span><br><span class="line">severName = <span class="string">&#x27;hostname&#x27;</span> 	<span class="comment">#提供或者包含服务器的IP地址或者包含服务器的主机名的字符串，使用主机名，则自动执行DNS lookup从而得到IP地址</span></span><br><span class="line">severPort = <span class="number">12000</span>    	<span class="comment">#端口号设置</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment">#创建了客户的套接字，称为clientSocket, AF_INET:示了底层网路使用了IPv4；第二个参数指示了套接字类型为UDP套接字而不是TCP套接字。</span></span><br><span class="line">message = raw_input(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>)<span class="comment">#用户输入信息</span></span><br><span class="line">clinetSocket.sendto(message.encode(), (severName, serverPort))<span class="comment">#首先将报文由字符串类型转换为字节类型，因为我们需要向套接字中发送字节；方法sendto()为报文附上目的地址并且向进程的套接字clinetSocket发送结果分组</span></span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)  <span class="comment">#当一个来自因特网的分组到达该客户套接字时，该分组的数据被放置到变量modifiedMessage中，其源地址被放置到变量severAddress。</span></span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode())   <span class="comment">#将报文从字节转化为字符串后，在显示器上打印出modifiedMessage</span></span><br><span class="line">clientSocket.close()    <span class="comment">#该行关闭了套接字，然后关闭了该进程</span></span><br></pre></td></tr></table></figure>

<ul>
<li>\2. UDPServer.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br></pre></td></tr></table></figure>

<p>serverSocket.bind((‘’,serverPort)) — 这行将端口号12000与该服务器的套接字绑定（即分配）在一起。因此在UDPServer中，代码显示地为该套接字分配一个端口号，以这种方式，当任何人向位于该服务器的IP地址的端口12000发送一个分组，该分组将导向该套接字。UDPServer然后进入一个while循环；该while循环将允许UDPServer无限期地接收并处理来自客户的分组。</p>
<h3 id="3-TCP套接字编程"><a href="#3-TCP套接字编程" class="headerlink" title="3.TCP套接字编程"></a>3.TCP套接字编程</h3><p>TCP是一个面向连接的协议，这意味着在客户和服务器能够开始相互发送数据之前，它们先要握手创建一个TCP连接。TCP连接的一端与客户套接字相联系，另一端与服务器套接字相联系。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675495843563-b4d89aa1-767c-48f2-b8cc-3fd84cb1e49d.png" alt="img"></p>
<p>客户程序创建一个TCP套接字，生成其TCP套接字时，指定了服务器中的欢迎套接字的地址，即服务器主机的IP地址及其套接字的端口号。生成其套接字后，该客户发起了一个三次握手并创建与服务器的一个TCP连接。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675496047718-7365fc59-e09d-4529-82da-3486da6106ec.png" alt="img"></p>
<h1 id="第3章-运输层"><a href="#第3章-运输层" class="headerlink" title="第3章 运输层"></a>第3章 运输层</h1><h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为<strong>运输层报文段</strong>（segment）</p>
<ul>
<li>运输层和网络层的关系</li>
</ul>
<p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。</p>
<p>如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带框保证。</p>
<h2 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h2><p>一台主机同时运行多个进程，一个进程有一个或多个套接字，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。</p>
<p>我们现在考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字：</p>
<ul>
<li>在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解。</strong></li>
<li>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong>。</li>
</ul>
<p>运输层多路复用要求：</p>
<ul>
<li>\1. 套接字有唯一标识符；</li>
<li>\2. 每个报文段有特殊字段来指示该报文所要交付的套接字。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675519198594-3d16e58d-3c1c-4806-b75f-70f552da98cf.png" alt="img"></p>
<p>端口号是一个16比特的数，有一些端口号是周知端口号，如HTTP的80号端口，FTP使用端口号21.</p>
<p>1.无连接的多路复用与多路分解</p>
<ul>
<li>一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675519923091-5ab6e4f2-9a14-4ecd-ab4b-925d4866b3fd.png" alt="img"></p>
<ol>
<li>面向连接的多路复用与多路分解</li>
</ol>
<ul>
<li>TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识。当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向（分解）到相应的套接字，不同与UDP的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同套接字，除非TCP报文段携带了初始创建连接的请求。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675520890386-d4fbcbe4-7095-4256-aca0-e339e34010f9.png" alt="img"></p>
<h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h2><p>有许多应用更适合用UDP，原因主要有以下几点：</p>
<ol>
<li>关于发送什么数据以及何时发送的应用层控制更为精细。实时应用通常要求最小的发送速率，不希望过分地延迟报文段的发送，且能容忍一些数据丢失，　TCP服务模型有一个拥塞控制机制，并不是特别适合这些应用的需要。</li>
<li>无须连接建立。TCP在开始数据传输之前要经过三次握手。UDP却不需要任何准备即可进行数据传输。因此UDP不会引入建立连接的时延。这可能是DNS运行在UDP之上而不是运行在TCP之上的主要原因。</li>
<li>无连接状态。 UDP不维护连接状态，也不跟踪这些参数。某些专门用于某种特定应用的服务器当应用程序运行在UDP之上而不是TCP之上，一般能支持更多的活跃客户。</li>
<li>分组首部开销小。每个TCP报文都有20字节的首部开销，而UDP仅有8字节的开销。</li>
</ol>
<h3 id="3-3-1-UDP报文段结构"><a href="#3-3-1-UDP报文段结构" class="headerlink" title="3.3.1 UDP报文段结构"></a>3.3.1 UDP报文段结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675562209630-4b02edf7-48c1-4ab7-b696-1d7f22286ad1.png" alt="img"><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675561907025-636c47a5-2a89-4ec7-889b-0e6c8f68c419.png" alt="img"></p>
<p>UDP首部只有4个字段，每个字段由两个字节组成。</p>
<p>长度字段指示了在UDP报文段中字节数（首部加数据）。接收使用校验和来检查在该报文段中是否出现了差错。</p>
<h3 id="3-3-2-UDP校验和"><a href="#3-3-2-UDP校验和" class="headerlink" title="3.3.2 UDP校验和"></a>3.3.2 UDP校验和</h3><p>UDP检验和提供了差错检测功能。<img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1675565703231-705b7c5e-c1e7-436c-b980-b179d999fae8.png" alt="img"></p>
<h2 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5 面向连接的运输：TCP"></a>3.5 面向连接的运输：TCP</h2><h3 id="3-5-1-TCP连接"><a href="#3-5-1-TCP连接" class="headerlink" title="3.5.1 TCP连接"></a>3.5.1 TCP连接</h3><ul>
<li>TCP被称为是面向连接的。</li>
<li>TCP协议只在端系统中运行，不在中间的网络元素中运行，中间的网络元素中不会维持TCP连接状态。</li>
<li>TCP连接总是点对点。</li>
<li><strong>三次握手：建立TCP连接的过程中，客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承接有效载荷。</strong></li>
<li><strong>MSS：</strong>最大报文段长度，限制报文段数据字段的最大长度</li>
<li>MTU：最大传输单元</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1676980349479-d53a2993-463f-46c0-b879-6d3e67f55ebc.png" alt="img"></p>
<h3 id="3-5-2-TCP报文段结构"><a href="#3-5-2-TCP报文段结构" class="headerlink" title="3.5.2 TCP报文段结构"></a>3.5.2 TCP报文段结构</h3><ul>
<li>TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1676980509501-03ce5b1c-c8b6-4ebb-86b1-dd28c631807c.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/25757674/1676982609371-5bcde7d7-e83f-44d9-b01e-5961c3450257.jpeg" alt="img"></p>
<ul>
<li><p>主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号。</p>
</li>
<li><p>累计确认</p>
</li>
<li><p>当主机在一条TCP连接中收到失序报文段时该怎么办？</p>
</li>
<li><ul>
<li>两个基本选择：1.接收方立即丢失失序报文段。2.接收方保留失序的字节，并等待缺少的字节以填补该间隔。这种做法对网络带宽而言更为有效。</li>
</ul>
</li>
<li><p>一个报文段的序号就是该报文段数据字段首字节的序号。</p>
</li>
<li><p>确认号就是主机正在等待的数据的下一个字节序号。</p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1676982287591-f1ba0699-8470-4297-9216-8604e1e70f5e.png" alt="img"></p>
</li>
<li><p>第一个报文段：客户发往服务器序号字段是42</p>
</li>
<li><p>第二个报文段：由服务器发往客户。两个目的：首先它是为该服务器所收到数据提供一个确认。通过在确认号字段中填入43，服务器告诉客户它已经成功地收到字节42及以前的所有字段，现在正等待字节43的出现。</p>
</li>
<li><p>第三个报文段：从客户发往服务器的。它的唯一目的是确认已从服务器收到的数据。</p>
</li>
</ul>
<h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5 流量控制"></a>3.5.5 流量控制</h3><ul>
<li>TCP 为它的应用程序提供了流量控制服务(flow- control service) 以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。</li>
<li>UDP不提供流量控制</li>
</ul>
<h3 id="3-5-6-TCP连接管理"><a href="#3-5-6-TCP连接管理" class="headerlink" title="3.5.6 TCP连接管理"></a>3.5.6 TCP连接管理</h3><ul>
<li><p>客户中的TCP 会用以下方式与服务器中的TCP 建立一条TCP 连接：</p>
</li>
<li><ul>
<li>笫一步： 客户端的TCP 首先向服务器端的TCP 发送一个特殊的TCP 报文段。该报文段中不包含应用层数据。但是在报文段的首部（参见图3-29) 中的一个标志位（即SYN 比特）被置为1 。因此，这个特殊报文段被称为SYN 报文段。另外，客户会随机地选择一个初始序号(client_isn) , 并将此编号放置千该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP 数据报中，并发送给服务器。</li>
<li>第二步： 一旦包含TCP SYN 报文段的IP 数据报到达服务器主机（假定它的确到达了），服务器会从该数据报中提取出TCP SYN 报文段，为该TCP 连接分配TCP 缓存和变量，并向该客户TCP 发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3 个重要的信息。首先， SYN 比特被置为1 。其次｀该TCP 报文段首部的确认号字段被置为client_isn + I 。最后，服务器选择自己的初始序号(server_isn) , 并将其放置到TCP 报文段首部的序号字段中。这个允许连接的报文段实际上表明了： “我收到了你发起建立连接的SYN 分组，该分组带有初始序号client_isn 。我同意建立该连接。我自己的初始序号是server_isn 。”该允许连接的报文段被称为SYNACK 报文段(SYNACK segment) 。</li>
</ul>
</li>
<li><ul>
<li>第三步： 在收到SYNACK 报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1 放置到TCP 报文段首部的确认字段中来完成此项工作） 。因为连接巳经建立了，所以该SYN 比特被置为0 。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</li>
</ul>
</li>
<li><p>注意到为了创建该连接，在两台主机之间发送了3 个分组， 如图3-39 所示。由千这个原因，这种连接创建过程通常被称为3次握手( three-way handshake)。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1676984241190-9e55c95f-0ad3-4178-a517-9fa3626f0fed.png" alt="img"></p>
<ul>
<li><p>一条TCP 连接的断开过程：</p>
</li>
<li><ul>
<li>客户端发送关闭连接命令。客户TCP向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部中的一个标志位即FIN比特被设置为1.</li>
<li>服务器接收到该报文段，向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其FIN比特被置为1。</li>
<li>最后，该客户对这个服务器的终止报文段进行确认。连接所用的所用资源被释放掉了。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1676984854531-58f4cd28-1fe9-47b6-81d3-b56ceeff7f8e.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1676985010773-d515b704-e309-4df5-aa5f-041f55ba6253.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1676985251075-a6ac34b1-da0e-4a68-a7b8-c75eb8a7decb.png" alt="img"></p>
<h2 id="3-6-拥塞"><a href="#3-6-拥塞" class="headerlink" title="3.6 拥塞"></a>3.6 拥塞</h2><h3 id="3-6-1-拥塞原因与代价"><a href="#3-6-1-拥塞原因与代价" class="headerlink" title="3.6.1 拥塞原因与代价"></a>3.6.1 拥塞原因与代价</h3><ul>
<li>拥塞网络的一种代价：当分组的到达速率接近链路容量时，分组经历巨大的排队时延。</li>
<li>另一种代价：当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。</li>
</ul>
<h3 id="3-6-2-拥塞控制方法"><a href="#3-6-2-拥塞控制方法" class="headerlink" title="3.6.2 拥塞控制方法"></a>3.6.2 拥塞控制方法</h3><ul>
<li>端到端拥塞控制</li>
<li>网络辅助的拥塞控制</li>
<li>默认因特网版本的IP和TCP采用端到端拥塞控制方法。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677130764564-ddabb280-a6d3-4f2d-aaa0-889b0203bce0.png" alt="img"></li>
<li>直接反馈信息可以由网络路由器发给发送方。</li>
<li>路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。</li>
</ul>
<h2 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h2><ul>
<li><p>TCP必须使用端到端拥塞控制而不是使网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。</p>
</li>
<li><p>TCP 所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果一个TCP 发送方感知从它到目的地之间的路径上没什么拥塞， 则TCP 发送方增加其发送速率；如果发送方感知沿着该路径有拥塞， 则发送方就会降低其发送速率</p>
</li>
<li><p>问题一：TCP发送方是如何限制向其连接发送流量的？</p>
</li>
<li><p>问题二：TCP 发送方是如何感知在它与目的地之间的路径上出现了拥塞的？</p>
</li>
<li><p>问题三：TCP 发送方怎样确定它应当发送的速率呢？</p>
</li>
<li><ul>
<li>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低TCP 发送方的</li>
</ul>
</li>
</ul>
<p>速率～</p>
<p>·一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前</p>
<p>未确认报文段的确认到达时，能够增加发送方的速率。</p>
<p>· 带宽探测</p>
<ul>
<li>TCP拥塞控制策略</li>
</ul>
<ol>
<li>慢启动</li>
</ol>
<ul>
<li>在慢启动状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加1个MSS。因此， TCP发送速率起始慢，但在慢启动阶段以指数增长。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677229044647-1614d71b-b56a-4bdc-8c95-94d246455838.png" alt="img"></p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677229064959-4d52d418-6550-4201-af86-65bca773307c.png" alt="img"></li>
</ul>
<ol>
<li>拥塞避免</li>
<li>快速恢复</li>
<li>TCP拥塞控制：回顾</li>
</ol>
<ul>
<li>ACK：确认字符</li>
<li>RTT（Round—Tip Time）：往返时间</li>
<li>RWND：滑动窗口</li>
<li>cwnd：拥塞窗口</li>
<li>MSS：最大报文长度</li>
<li>TCP的拥塞控制是：每个RTT内cwnd线性（加性）增加1MSS，然后出现3个冗余ACK事件时cwnd减半（乘性减）。TCP 拥塞控制常常被称为 加性 增、乘性减(Additive-Increase. Multiplicative- Decreasf’ ~ A IMO) 拥塞控制方式。</li>
</ul>
<h1 id="4-网络层：数据平面"><a href="#4-网络层：数据平面" class="headerlink" title="4.网络层：数据平面"></a>4.网络层：数据平面</h1><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677230571849-c2fd1cca-c7ff-4750-9b6c-9fb0ad01522c.png" alt="img"></p>
<ul>
<li>网络层的作用：1.转发 2. 路由选择</li>
<li><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677230792783-7920c148-f277-4f08-811b-abeb1dce1b23.png" alt="img"></li>
<li>转发是由网络层的数据平面执行的主要功能。</li>
<li>路由选择算法决定了插入该路由器转发表的内容。</li>
</ul>
<h3 id="4-1-2-网络服务模型"><a href="#4-1-2-网络服务模型" class="headerlink" title="4.1.2 网络服务模型"></a>4.1.2 网络服务模型</h3><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677236714004-6744b46a-a68a-47f9-acd2-d6a895661732.png" alt="img"></li>
</ul>
<h2 id="4-2-路由器工作原理"><a href="#4-2-路由器工作原理" class="headerlink" title="4.2 路由器工作原理"></a>4.2 路由器工作原理</h2><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677237122599-716aca2d-e32b-4fcd-a77a-097805fcc8c6.png" alt="img"></li>
<li>路由器的输入端口、输出端口核交换结构几乎总是用硬件实现。</li>
<li>路由器使用转发表来查找输出端口，使得到达的分组能经过交换结构转发到该输出端口。</li>
</ul>
<h3 id="4-2-2-交换"><a href="#4-2-2-交换" class="headerlink" title="4.2.2 交换"></a>4.2.2 交换</h3><ul>
<li>交换结构使得分组实际地从一个输入端口交换（即转发）到一个输出端口。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677238120233-d74b2f66-5dd8-43fe-85eb-43241cfcd39a.png" alt="img"></p>
<ul>
<li>交换技术：1.经内存交换；2.经总线交换；3. 经互联网网络交换</li>
</ul>
<h3 id="4-2-3-输出端口处理"><a href="#4-2-3-输出端口处理" class="headerlink" title="4.2.3 输出端口处理"></a>4.2.3 输出端口处理</h3><ul>
<li>输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677238413089-9d78ace0-f1a9-4e95-95ab-a6ed913456e1.png" alt="img"></li>
</ul>
<h3 id="4-2-5-分组调度"><a href="#4-2-5-分组调度" class="headerlink" title="4.2.5 分组调度"></a>4.2.5 分组调度</h3><ul>
<li>即排队的分组如何经输出链路传输的问题。</li>
</ul>
<ol>
<li>先进先出</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677238766766-f4876956-03fc-45fa-8fa2-4752e316c344.png" alt="img"></p>
<ol>
<li>优先权排队</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677238802382-e37a0973-d282-4767-858e-37ce2ea4f39f.png" alt="img"></p>
<ol>
<li>循环和加权公平排队</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1677239009556-42549eca-eb46-4ae6-b50c-af78999fcadf.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="clmrundc2000cwstjf3t80kdm" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线程池" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.040Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ol>
<li><h2 id="为什么需要线程池？"><a href="#为什么需要线程池？" class="headerlink" title="为什么需要线程池？"></a>为什么需要线程池？</h2></li>
</ol>
<p>在程序中，如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>我们想要实现使得线程可以复用，执行完不被销毁，可以继续执行其他的任务。线程池就登场了。</p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p>
<p>每个线程都是后台线程，使用默认堆栈大小，默认优先级运行。</p>
<ol start="2">
<li><h2 id="线程池原理："><a href="#线程池原理：" class="headerlink" title="线程池原理："></a>线程池原理：</h2></li>
</ol>
<p>分为三部分：</p>
<p><strong>1.任务队列</strong></p>
<p>存储需要处理的任务，由工作的线程来处理这些任务</p>
<p><strong>2.工作的线程</strong></p>
<p>有N个线程，作用：不停的读任务队列，从里面取出任务并处理，是任务队列任务的消费者。</p>
<p>如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量&#x2F;信号量阻塞)</p>
<p>如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作</p>
<p><strong>3.管理者线程</strong></p>
<p>只有一个，它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</p>
<p>当任务过多的时候, 可以适当的创建一些新的工作线程<br>当任务过少的时候, 可以适当的销毁一些工作的线程</p>
<p><img src="C:\Users\ZYY\AppData\Roaming\Typora\typora-user-images\image-20230830172852264.png" alt="image-20230830172852264"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" data-id="clmrundc0000awstj38i84foc" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线程同步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.036Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C语言中的线程同步"><a href="#C语言中的线程同步" class="headerlink" title="C语言中的线程同步"></a>C语言中的线程同步</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>当一个线程对内存中的共享资源进行访问的时候，其他线程都不可以操作这块内存，直到线程 A 对这块内存访问完毕为止。</p>
<h2 id="2-为什么要实现线程同步"><a href="#2-为什么要实现线程同步" class="headerlink" title="2 为什么要实现线程同步"></a>2 为什么要实现线程同步</h2><p>为了使多个线程操作同一个全局变量的时候，全局变量的数据被及时正确的读取、计算、写入内存中，保证程序正确的执行下去。</p>
<h2 id="3-同步方式"><a href="#3-同步方式" class="headerlink" title="3 同步方式"></a>3 同步方式</h2><ul>
<li>互斥锁 </li>
<li>读写锁</li>
<li>条件变量</li>
<li>信号量</li>
</ul>
<blockquote>
<p>所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为临界资源。</p>
</blockquote>
<p><img src="https://subingwen.cn/linux/thread-sync/image-20200106092600543.png" alt="image-20200106092600543"></p>
<ul>
<li>临界区上边上锁，下边解锁</li>
</ul>
<h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1. 互斥锁"></a>1. 互斥锁</h3><ul>
<li><p>通过互斥锁可以锁定一个代码块，</p>
</li>
<li><p>被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要<strong>付出的代价就是执行效率的降低</strong>，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p>
</li>
<li><p>创建一把互斥锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数:</span></span><br><span class="line"><span class="comment">//mutex: 互斥锁变量的地址</span></span><br><span class="line"><span class="comment">//attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试加锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(pthread_mutex* mutex)</span>;</span><br><span class="line"><span class="comment">//如果锁变量是锁定的，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(pthread_mutex* mutex)</span>;</span><br><span class="line"><span class="comment">//不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>死锁</strong>：锁使用不当，如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p>
<p>造成死锁的场景有：</p>
<ul>
<li><p>加锁后忘记解锁</p>
</li>
<li><p>重复加锁，造成死锁</p>
</li>
<li><p>程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">场景描述:</span><br><span class="line">  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B</span><br><span class="line">     - 线程A访问资源X, 加锁A</span><br><span class="line">     - 线程B访问资源Y, 加锁B</span><br><span class="line">  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞</span><br><span class="line">     - 线程A被锁B阻塞了, 无法打开A锁</span><br><span class="line">     - 线程B被锁A阻塞了, 无法打开B锁</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h3 id="2-读写锁-–-是互斥锁的升级版"><a href="#2-读写锁-–-是互斥锁的升级版" class="headerlink" title="2. 读写锁  – (是互斥锁的升级版)"></a>2. 读写锁  – (是互斥锁的升级版)</h3><ul>
<li><p>创建 ：<code>pthread_rwlock_t rwlock;</code> </p>
</li>
<li><p>在<strong>做读操作的时候可以提高程序的执行效率</strong>，如果所有的线程都是做读操作, 那么读是并行的</p>
</li>
<li><p>如果读写锁锁定了读操作，需要先解锁才能锁定写操作，反之亦然。</p>
</li>
<li><p>读写锁的特点：</p>
<ol>
<li>读锁是共享的</li>
<li>写锁是独占的</li>
<li>写锁比读锁的优先级高。</li>
</ol>
</li>
</ul>
<blockquote>
<p>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源<strong>读的操作越多，读写锁更有优势</strong>。</p>
</blockquote>
<ul>
<li><ul>
<li>读写锁是一把锁， 锁定了读操作，就不能锁定写操作了，不能同时锁定。</li>
</ul>
</li>
<li>读写锁的操作函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">//初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">//attr: 读写锁属性，一般使用默认属性，指定为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlocck)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlocck)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h3><p><strong>条件变量的主要作用不是处理线程同步，而是进行线程的阻塞</strong>。<strong>在多线程程序中，条件变量需要配合互斥锁来使用。</strong></p>
<p>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</p>
<p><strong>分工</strong>：互斥锁用来做线程同步；条件变量用来阻塞线程的。</p>
<ul>
<li>条件变量的操作函数如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* <span class="keyword">restrict</span> attr)</span>;<span class="comment">//att 指定为NULL</span></span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line">	<span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h4><p><img src="https://subingwen.cn/linux/thread-sync/1564644834918.png" alt="1564644834918"></p>
<p>生产者和消费者模型的组成：</p>
<ol>
<li>生产者线程 -&gt; 若干个<ol>
<li>生产商品或者任务放入到任务队列中</li>
<li>任务队列满了就阻塞，不满的时候就工作</li>
<li>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</li>
</ol>
</li>
<li>消费者线程 -&gt; 若干个<ol>
<li>读任务队列，将任务或者数据取出</li>
<li>任务队列中有数据就消费，没有数据就阻塞</li>
<li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li>
</ol>
</li>
<li>队列-&gt;存储任务 &#x2F; 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存<ul>
<li>可以是数组、链表，也可以使用 <code>stl</code>容器：<code>queue / stack / list / vector</code></li>
</ul>
</li>
</ol>
<h3 id="4-信号量–-用起来比条件变量简单"><a href="#4-信号量–-用起来比条件变量简单" class="headerlink" title="4. 信号量–  用起来比条件变量简单"></a>4. 信号量–  用起来比条件变量简单</h3><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。<strong>信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</strong></p>
<p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为<code>sem_t</code>对应的头文件为 <code>&lt;semaphore.h&gt;：</code></p>
<p>信号量操作函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建信号量</span></span><br><span class="line"><span class="type">sem_t</span> sem1;</span><br><span class="line"><span class="type">sem_t</span> sem2;</span><br><span class="line"><span class="comment">//初始化信号量/灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数       </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数:<br><code>sem</code>：信号量变量地址<br><code>pshared</code>：<br>0：线程同步<br>非 0：进程同步<br>value：初始化当前信号量拥有的资源数（&gt;&#x3D;0），如果资源数为 0，线程就会被阻塞了.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">// sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号</span></span><br></pre></td></tr></table></figure>

<p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line"><span class="comment">//查看信号量sem中的整型数的当前值，个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span>* sval)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="总资源数为1"><a href="#总资源数为1" class="headerlink" title="总资源数为1"></a>总资源数为1</h4><p>如果生产者和消费者使用的信号量总资源数为 1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p>
<h4 id="总资源数大于-1"><a href="#总资源数大于-1" class="headerlink" title="总资源数大于 1"></a><strong>总资源数大于 1</strong></h4><p><strong>为防止共享资源出现数据混乱，需要使用互斥锁进行线程同步。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//作者: 苏丙榅</span></span><br><span class="line"><span class="comment">//链接: https://subingwen.cn/linux/thread-sync/</span></span><br><span class="line"><span class="comment">//来源: 爱编程的大丙</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>

<p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" data-id="clmrundc1000bwstjbpmu2kzf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-现代操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.034Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h1><ul>
<li>使单线程代码多线程化 ， 方案：</li>
</ul>
<ol>
<li><ol>
<li>全面禁止全局变量，每个线程都有自己的全局变量的私有副本，这些变量对一个线程中的所有过程都可见。</li>
<li>可以引入新的库过程，方便创建设置和读取这些线程范围的全局变量。</li>
</ol>
</li>
</ol>
<h2 id="2-3-进程间通信"><a href="#2-3-进程间通信" class="headerlink" title="2.3 进程间通信"></a>2.3 进程间通信</h2><ul>
<li><p>竞争条件<br>  两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精准时许。 </p>
</li>
<li><p>临界区<br>  互斥：以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。<br>  避免竞争条件：在一个进程的一部分时间内做内部计算或其他不会引发竞争条件的操作。一个进程在运行时，别的进程不来干扰。 </p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1679569750534-32a3c578-9ed0-47aa-a3d8-df296354603b.png" alt="img"></p>
</li>
<li><p>忙等待的互斥<br>  讨论几种实现互斥的方案 </p>
</li>
<li><ul>
<li>屏蔽中断（不太好）</li>
</ul>
</li>
</ul>
<p>	</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25757674/1679569767898-64eee541-2520-42ff-bdd1-a20a181e18d0.png" alt="img"></p>
<ul>
<li><ul>
<li>锁变量（有疏漏） </li>
<li>严格轮换法<br>  用于忙等待的锁，称为自旋锁 </li>
<li>Peterson解法 </li>
<li>TSL指令 </li>
<li></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="clmrundbx0007wstj1pd3427q" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.029Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构-代码随想录"><a href="#数据结构-代码随想录" class="headerlink" title="数据结构-代码随想录"></a>数据结构-代码随想录</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>类型<ul>
<li><p>一维数组</p>
</li>
<li><p>多维数组</p>
</li>
</ul>
</li>
<li>存储方式 <ul>
<li>在内存连续存储，数组名就是数组的第一个元素的地址 a &#x3D; &amp;a[0]</li>
</ul>
</li>
<li>应用场景<ul>
<li>数据量固定不变，频繁查询，较少增删</li>
</ul>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>类型<ul>
<li>单链表</li>
<li>双链表</li>
<li>循环链表</li>
</ul>
</li>
<li>存储方式<ul>
<li>链表中的节点在内存中不是连续分布的，散落在内存中，依靠操作系统的内存管理进行分配</li>
</ul>
</li>
<li>操作<ul>
<li>删除节点</li>
<li>添加节点</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>插入&#x2F;删除：O（1）</li>
<li>查询：O（n）</li>
</ul>
</li>
<li>应用场景<ul>
<li>数据量不固定，经常增删，较少查询</li>
</ul>
</li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>解决的问题<ul>
<li>快速判断一个元素是否出现在集合里</li>
<li>牺牲了空间换时间</li>
</ul>
</li>
<li>常见的三种哈希结构<ul>
<li>数组</li>
<li>set(集合)<ul>
<li>unordered_set<ul>
<li>查询和增删效率是最优</li>
</ul>
</li>
<li>set<ul>
<li>数据有序，不重复</li>
</ul>
</li>
<li>multiset<ul>
<li>数据有序，可重复</li>
</ul>
</li>
</ul>
</li>
<li>map（映射）<ul>
<li>key-value数据结构</li>
<li>key的存储方式使用红黑树</li>
<li>类型<ul>
<li>unordered_map<ul>
<li>哈希表实现</li>
</ul>
</li>
<li>map<ul>
<li>红黑树实现</li>
</ul>
</li>
<li>multimap<ul>
<li>红黑树实现</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="clmrundby0008wstj0b8h41tl" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-拷贝控制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.026Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><ul>
<li>一个类需要5种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁操作。</li>
<li>拷贝控制操作：<ul>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果我们的一个类没有定义这些操作，编译器会自动合成缺少的操作</p>
</blockquote>
<p>- </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" data-id="clmrundbz0009wstjeyv9bxkx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.023Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C语言中的线程"><a href="#C语言中的线程" class="headerlink" title="C语言中的线程"></a>C语言中的线程</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><ol>
<li><p>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p>
</li>
<li><p>进程和线程的区别：</p>
<ul>
<li><p>进程有自己独立的地址空间，多个线程共用同一个地址空间。</p>
<ul>
<li><p>在一个地址空间中，多个线程独享：栈区，寄存器。</p>
</li>
<li><p>在一个地址空间中，多个线程共享：代码区，堆区，全局数据区，打开的文件。</p>
</li>
</ul>
</li>
<li><p>线程是程序的最小执行单元，进程是最小的资源分配单位。</p>
</li>
<li><p>CPU的调度和切换：线程的上下文切换比进程要快的多。</p>
</li>
<li><p>线程更加廉价，启动速度快，退出快，对系统资源的冲击小。</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">phread_t</span> <span class="title">phread_self</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//线程函数，返回当前线程的ID</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</span></span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟地址空间的生命周期和主线程是一样的，与子线程无关。</li>
<li>sleep（）：可以让主线程挂起，让子线程执行完毕，主线程再退出。</li>
</ul>
<h2 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">phtread_eixt</span><span class="params">(<span class="type">void</span> *retval)</span></span>;<span class="comment">//只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。</span></span><br><span class="line"><span class="comment">//主线程调用退出函数退出, 地址空间不会被释放</span></span><br></pre></td></tr></table></figure>

<h2 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h2><blockquote>
<p>子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做<code> pthread_join()</code>，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p>
</blockquote>
<h3 id="4-1-回收子线程数据"><a href="#4-1-回收子线程数据" class="headerlink" title="4.1 回收子线程数据"></a>4.1 回收子线程数据</h3><ul>
<li><p>使用子线程栈 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_exit</span>(&amp;p); <span class="comment">//子线程退出</span></span><br><span class="line"><span class="built_in">pthread_join</span>(tid, &amp;ptr); <span class="comment">//主线程回收子线程资源，通过ptr void*类型指针传出子线程数据。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>使用全局变量</p>
<ul>
<li>位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是<strong>可以共享全局数据区和堆区数据</strong>，因此在子线程退出的时候可以将<strong>传出数据存储到全局变量、静态变量或者堆内存</strong>中。</li>
</ul>
</li>
<li><p>使用主线程栈</p>
</li>
</ul>
<h2 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 <code>pthread_join()</code> 就回收不到子线程资源了。</p>
</li>
<li><p>为何使用线程分离：因为主线程有自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code> pthread_join()</code> 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p>
</li>
</ul>
<h2 id="6-其他线程函数"><a href="#6-其他线程函数" class="headerlink" title="6. 其他线程函数"></a>6. 其他线程函数</h2><ul>
<li><p>线程取消</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span>, thread)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用这个函数杀死一个线程需要分两步：</p>
<p>在线程 A 中调用线程取消函数 <code>pthread_cancel</code>，指定杀死线程 B，这时候线程 B 是死不了的<br>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。</p>
</blockquote>
</li>
<li><p>线程ID比较</p>
<ul>
<li><p>在 Linux 中线程 ID 本质就是一个无符号长整形，在某些平台上<code>pthread_t</code>可能不是一个单纯的整形，这种情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数：t1 和 t2 是要比较的线程的线程 ID<br>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</p>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="clmrundbw0006wstjgxwp50d1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-图解网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/20/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2023-09-20T14:38:32.020Z" itemprop="datePublished">2023-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="图解网络"><a href="#图解网络" class="headerlink" title="图解网络"></a>图解网络</h1><ul>
<li>HTTP是一个在计算机里在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</li>
</ul>
<h2 id="HTTP常见的状态码："><a href="#HTTP常见的状态码：" class="headerlink" title="HTTP常见的状态码："></a>HTTP常见的状态码：</h2><ul>
<li>1XX开头的：是处理的中间状态</li>
<li>2xx开头的是：成功了</li>
<li>3xx开头的是：重定向</li>
<li>4xx：客户端错误</li>
<li>5xx：服务器错误</li>
</ul>
<h2 id="HTTP常见字段："><a href="#HTTP常见字段：" class="headerlink" title="HTTP常见字段："></a>HTTP常见字段：</h2><ul>
<li><p>Host ：客户端指定服务器的域名</p>
</li>
<li><p>content-Length：服务器回应的数据长度</p>
</li>
<li><p>connection: 客户端要求服务器保持长连接状态。keep-Alive</p>
</li>
<li><p>content-Type: 服务器回应客户端。本次数据是啥格式。</p>
</li>
<li><p>content-encoding:说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
</li>
</ul>
<h2 id="GET和POST的区别："><a href="#GET和POST的区别：" class="headerlink" title="GET和POST的区别："></a>GET和POST的区别：</h2><ul>
<li>get是从服务器获取指定资源，请求的位置写在url中，参数只允许ASCII字符。</li>
<li>post是根据请求负荷（报文body）对指定的资源做出处理。请求携带数据的位置一般在报文body中，数据格式任意。</li>
</ul>
<h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><ul>
<li>强制缓存</li>
<li>协商缓存</li>
</ul>
<h2 id="HTTP-1-1的特性"><a href="#HTTP-1-1的特性" class="headerlink" title="HTTP&#x2F;1.1的特性"></a>HTTP&#x2F;1.1的特性</h2><ul>
<li>HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」</li>
<li>缺点：无状态，明文传输，不安全</li>
</ul>
<blockquote>
<p>无状态是把双刃剑：优点：因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担。</p>
<p>缺点：服务器没有记忆能力，完成有关联性的操作是会麻烦。</p>
<p>解决方法：使用<code>Cookie</code>技术。<code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p>不安全：使用HTTPS解决，引入SSL&#x2F;TLS层</p>
</blockquote>
<h2 id="HTTP-1-1-的性能如何？-（一般般）"><a href="#HTTP-1-1-的性能如何？-（一般般）" class="headerlink" title="HTTP&#x2F;1.1 的性能如何？ （一般般）"></a>HTTP&#x2F;1.1 的性能如何？ （一般般）</h2><ul>
<li><ol>
<li>长连接或叫持久连接，好处：减少了TCP频繁连接造成的额外开销，减轻了服务器端的负载。</li>
</ol>
</li>
<li><ol start="2">
<li>实现管道网络传输。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></li>
</ol>
</li>
<li><ol start="3">
<li>队头阻塞。顺序发送的请求序列中的一个请求被阻塞，后面的请求都阻塞了，客户端会一直请求不到数据。</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/18-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.png" alt="队头阻塞"></p>
<h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="1-区别"><a href="#1-区别" class="headerlink" title="1.区别"></a>1.区别</h3><p>HTTP明文传输，存在安全问题。</p>
<p>HTTPS使报文加密传输。</p>
<p>HTTP连接简单，TCP三次握手；HTTPS还需要SSL&#x2F;TLS的握手过程。</p>
<p>HTTP端口80；HTTPS端口443，要申请数字证书。</p>
<h3 id="2-HTTPS解决了HTTP的啥问题"><a href="#2-HTTPS解决了HTTP的啥问题" class="headerlink" title="2.HTTPS解决了HTTP的啥问题"></a>2.HTTPS解决了HTTP的啥问题</h3><p>解决了安全问题（窃听、篡改、冒充风险）</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"></p>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险。</p>
<p>实现了1.信息加密 2.校验机制 3.身份证书</p>
<p>实现手段：混合加密，摘要算法（哈希函数），数字证书</p>
<h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><p>SSL&#x2F;TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<h2 id="https-和-http-相比，就是传输的内容多了对称加密，可以这么理解吗？"><a href="#https-和-http-相比，就是传输的内容多了对称加密，可以这么理解吗？" class="headerlink" title="https 和 http 相比，就是传输的内容多了对称加密，可以这么理解吗？"></a>https 和 http 相比，就是传输的内容多了对称加密，可以这么理解吗？</h2><ol>
<li>建立连接时候：https 比 http多了 TLS 的握手过程；</li>
<li>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</li>
</ol>
<h2 id="HTTP-1-1-如何优化？"><a href="#HTTP-1-1-如何优化？" class="headerlink" title="HTTP&#x2F;1.1 如何优化？"></a>HTTP&#x2F;1.1 如何优化？</h2><p>三种思路</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96http1.1%E6%8F%90%E7%BA%B2.png" alt="img" style="zoom:67%;" />

<h3 id="1-如何避免发送-HTTP-请求？"><a href="#1-如何避免发送-HTTP-请求？" class="headerlink" title="1.如何避免发送 HTTP 请求？"></a>1.如何避免发送 HTTP 请求？</h3><ul>
<li><p>客户端会把第一次向服务器发送的请求和收到的响应保存到本地磁盘上。下一次客户端发起相同的请求时会先在本地磁盘上查询。如果缓存的响应过期了（查看响应头部信息），客户端会向服务器发送请求。在请求的<code>Etag</code> 头部会带上第一次响应头部的摘要，服务器把自己的和客户端缓存的资源的摘要比照，没有过期就发送304重定向状态码，告诉客户端你的缓存还有效。这样就可以减少响应资源在网络中传输的延时，如下图：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img" style="zoom: 50%;" /></li>
</ul>
<h3 id="2-如何减少-HTTP-请求次数？"><a href="#2-如何减少-HTTP-请求次数？" class="headerlink" title="2.如何减少 HTTP 请求次数？"></a>2.如何减少 HTTP 请求次数？</h3><h4 id="1-减少重定向请求次数"><a href="#1-减少重定向请求次数" class="headerlink" title="1. 减少重定向请求次数"></a>1. 减少重定向请求次数</h4><p>当资源从服务器1（url1）转移到服务器2（url2），客户端仍向url1发送请求就会收到3xx重定向，客户端就要再向url2发送请求。但是客户端和源服务器之间架设代理服务器（nginx），代理服务器可以完成重定向的工作，就能减少HTTP请求次数了。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" style="zoom:67%;" />

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img" style="zoom: 67%;" />

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.png" alt="img" style="zoom:67%;" />

<h4 id="2-合并请求"><a href="#2-合并请求" class="headerlink" title="2. 合并请求"></a>2. 合并请求</h4><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着<strong>减少了重复发送的 HTTP 头部</strong>。</p>
<ul>
<li>合并请求的方式<ul>
<li>使用 <code>CSS Image Sprites</code> 技术把网页的含有很多小图片、小图标合成一个大图片。</li>
<li>服务端使用 <code>webpack</code> 等打包工具将 js、css 等资源合并打包成大文件。</li>
<li>将图片的二进制数据用 <code>base64</code> 编码随HTML文件一起发送，客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片。</li>
</ul>
</li>
</ul>
<blockquote>
<p>弊端：<strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件</strong>，这显然带来了额外的网络消耗。</p>
</blockquote>
<h4 id="3-延迟发送请求"><a href="#3-延迟发送请求" class="headerlink" title="3.  延迟发送请求"></a>3.  延迟发送请求</h4><p>「<strong>按需获取</strong>」请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源。</p>
<h3 id="3-如何减少-HTTP-响应的数据大小？"><a href="#3-如何减少-HTTP-响应的数据大小？" class="headerlink" title="3. 如何减少 HTTP 响应的数据大小？"></a>3. 如何减少 HTTP 响应的数据大小？</h3><ul>
<li>压缩数据<ul>
<li>无损压缩 <code>gzip  </code> <code>Brotli </code> 压缩算法</li>
<li>有损压缩</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/20/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" data-id="clmrundbv0005wstjg3xgdy9j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/20/%E7%BD%91%E7%9B%98%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/">网盘项目笔记</a>
          </li>
        
          <li>
            <a href="/2023/09/20/%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/20/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>